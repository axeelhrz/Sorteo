"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_services_raffle-service_ts",{

/***/ "(app-pages-browser)/./src/services/firebase-raffle-service.ts":
/*!*************************************************!*\
  !*** ./src/services/firebase-raffle-service.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   firebaseRaffleService: function() { return /* binding */ firebaseRaffleService; }\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/../node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* harmony import */ var _types_raffle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/types/raffle */ \"(app-pages-browser)/./src/types/raffle.ts\");\n\n\n\n// Helper para convertir Firestore timestamp a Date\nconst convertTimestamp = (timestamp)=>{\n    if (timestamp === null || timestamp === void 0 ? void 0 : timestamp.toDate) {\n        return timestamp.toDate();\n    }\n    if (timestamp instanceof Date) {\n        return timestamp;\n    }\n    if (typeof timestamp === \"string\") {\n        return new Date(timestamp);\n    }\n    return new Date();\n};\n// Helper para convertir documento de Firestore a Raffle\nconst convertRaffleDoc = async (docSnap)=>{\n    const data = docSnap.data();\n    const raffle = {\n        id: docSnap.id,\n        shopId: data.shopId || \"\",\n        productId: data.productId || \"\",\n        productValue: data.productValue || 0,\n        totalTickets: data.totalTickets || 0,\n        soldTickets: data.soldTickets || 0,\n        status: data.status || _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.DRAFT,\n        requiresDeposit: data.requiresDeposit || false,\n        winnerTicketId: data.winnerTicketId,\n        specialConditions: data.specialConditions,\n        createdAt: convertTimestamp(data.createdAt),\n        updatedAt: convertTimestamp(data.updatedAt),\n        activatedAt: data.activatedAt ? convertTimestamp(data.activatedAt) : undefined,\n        raffleExecutedAt: data.raffleExecutedAt ? convertTimestamp(data.raffleExecutedAt) : undefined\n    };\n    // Cargar relaciones si existen\n    if (data.shopId) {\n        try {\n            const shopDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"shops\", data.shopId));\n            if (shopDoc.exists()) {\n                const shopData = shopDoc.data();\n                raffle.shop = {\n                    id: shopDoc.id,\n                    userId: shopData.userId || \"\",\n                    name: shopData.name || \"\",\n                    description: shopData.description,\n                    logo: shopData.logo,\n                    publicEmail: shopData.publicEmail,\n                    phone: shopData.phone,\n                    socialMedia: shopData.socialMedia,\n                    status: shopData.status || \"pending\",\n                    createdAt: convertTimestamp(shopData.createdAt),\n                    updatedAt: convertTimestamp(shopData.updatedAt)\n                };\n            }\n        } catch (error) {\n            console.error(\"Error loading shop:\", error);\n        }\n    }\n    if (data.productId) {\n        try {\n            const productDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"products\", data.productId));\n            if (productDoc.exists()) {\n                const productData = productDoc.data();\n                raffle.product = {\n                    id: productDoc.id,\n                    shopId: productData.shopId || \"\",\n                    name: productData.name || \"\",\n                    description: productData.description || \"\",\n                    value: productData.value || 0,\n                    height: productData.height || 0,\n                    width: productData.width || 0,\n                    depth: productData.depth || 0,\n                    requiresDeposit: productData.requiresDeposit || false,\n                    category: productData.category,\n                    mainImage: productData.mainImage,\n                    status: productData.status || \"inactive\",\n                    createdAt: convertTimestamp(productData.createdAt),\n                    updatedAt: convertTimestamp(productData.updatedAt)\n                };\n            }\n        } catch (error) {\n            console.error(\"Error loading product:\", error);\n        }\n    }\n    return raffle;\n};\nconst firebaseRaffleService = {\n    /**\n   * Obtiene sorteos activos con filtros y búsqueda\n   */ async getActiveRaffles (filters) {\n        try {\n            const rafflesRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"raffles\");\n            // Intentar consulta con filtro de status, pero si falla por índice, obtener todos y filtrar\n            let allDocs;\n            try {\n                let q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(rafflesRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.ACTIVE));\n                // Aplicar filtros adicionales\n                if (filters === null || filters === void 0 ? void 0 : filters.shopId) {\n                    q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"shopId\", \"==\", filters.shopId));\n                }\n                // Intentar ordenar si no hay filtro de shopId (para evitar problemas de índices compuestos)\n                if (!(filters === null || filters === void 0 ? void 0 : filters.shopId)) {\n                    try {\n                        if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"newest\") {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"createdAt\", \"desc\"));\n                        } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"closest\") {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"soldTickets\", \"desc\"));\n                        } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"price-asc\") {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"productValue\", \"asc\"));\n                        } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"price-desc\") {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"productValue\", \"desc\"));\n                        } else {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"createdAt\", \"desc\"));\n                        }\n                        allDocs = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n                    } catch (orderError) {\n                        // Si falla el orderBy, intentar sin ordenar\n                        console.warn(\"Error con orderBy, obteniendo sin ordenar:\", orderError);\n                        if (filters === null || filters === void 0 ? void 0 : filters.shopId) {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(rafflesRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.ACTIVE), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"shopId\", \"==\", filters.shopId));\n                        } else {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(rafflesRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.ACTIVE));\n                        }\n                        allDocs = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n                    }\n                } else {\n                    allDocs = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n                }\n            } catch (queryError) {\n                // Si falla la consulta con where, obtener todos y filtrar en memoria\n                console.warn(\"Error en consulta con where, obteniendo todos los sorteos:\", queryError);\n                const allRafflesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(rafflesRef);\n                const allRafflesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(allRafflesQuery);\n                // Filtrar por status activo en memoria\n                allDocs = {\n                    docs: allRafflesSnapshot.docs.filter((doc)=>{\n                        const status = doc.data().status;\n                        return status === _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.ACTIVE || status === \"active\";\n                    })\n                };\n                console.log(\"\\uD83D\\uDCCA Sorteos activos encontrados despu\\xe9s de filtrar: \".concat(allDocs.docs.length, \" de \").concat(allRafflesSnapshot.docs.length, \" totales\"));\n            }\n            let raffles = [];\n            // Convertir documentos\n            for (const docSnap of allDocs.docs){\n                try {\n                    const raffle = await convertRaffleDoc(docSnap);\n                    raffles.push(raffle);\n                } catch (error) {\n                    console.error(\"Error converting raffle doc:\", error);\n                }\n            }\n            console.log(\"✅ Sorteos activos cargados: \".concat(raffles.length));\n            // Aplicar filtros que requieren los datos completos\n            if (filters === null || filters === void 0 ? void 0 : filters.category) {\n                raffles = raffles.filter((r)=>{\n                    var _r_product;\n                    return ((_r_product = r.product) === null || _r_product === void 0 ? void 0 : _r_product.category) === filters.category;\n                });\n            }\n            if ((filters === null || filters === void 0 ? void 0 : filters.minValue) !== undefined) {\n                raffles = raffles.filter((r)=>r.productValue >= filters.minValue);\n            }\n            if ((filters === null || filters === void 0 ? void 0 : filters.maxValue) !== undefined) {\n                raffles = raffles.filter((r)=>r.productValue <= filters.maxValue);\n            }\n            if (filters === null || filters === void 0 ? void 0 : filters.search) {\n                const searchLower = filters.search.toLowerCase();\n                raffles = raffles.filter((r)=>{\n                    var _r_product, _r_product1, _r_shop;\n                    return ((_r_product = r.product) === null || _r_product === void 0 ? void 0 : _r_product.name.toLowerCase().includes(searchLower)) || ((_r_product1 = r.product) === null || _r_product1 === void 0 ? void 0 : _r_product1.description.toLowerCase().includes(searchLower)) || ((_r_shop = r.shop) === null || _r_shop === void 0 ? void 0 : _r_shop.name.toLowerCase().includes(searchLower));\n                });\n            }\n            // Ordenar en memoria si hay filtro de shopId o si no se pudo ordenar en la consulta\n            if ((filters === null || filters === void 0 ? void 0 : filters.shopId) || (filters === null || filters === void 0 ? void 0 : filters.sortBy)) {\n                if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"newest\") {\n                    raffles.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n                } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"closest\") {\n                    raffles.sort((a, b)=>b.soldTickets - a.soldTickets);\n                } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"price-asc\") {\n                    raffles.sort((a, b)=>a.productValue - b.productValue);\n                } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"price-desc\") {\n                    raffles.sort((a, b)=>b.productValue - a.productValue);\n                }\n            }\n            // Aplicar paginación manual\n            const total = raffles.length;\n            const totalPages = Math.ceil(total / pageSize);\n            const paginatedRaffles = raffles.slice(offset, offset + pageSize);\n            return {\n                data: paginatedRaffles,\n                total,\n                page,\n                limit: pageSize,\n                totalPages\n            };\n        } catch (error) {\n            console.error(\"Error fetching active raffles:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Obtiene un sorteo específico por ID (público)\n   */ async getRaffleById (id) {\n        try {\n            const raffleDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"raffles\", id));\n            if (!raffleDoc.exists()) {\n                throw new Error(\"Raffle not found\");\n            }\n            return await convertRaffleDoc(raffleDoc);\n        } catch (error) {\n            console.error(\"Error fetching raffle:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Obtiene sorteos de una tienda específica (público)\n   */ async getRafflesByShop (shopId, filters) {\n        try {\n            const rafflesRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"raffles\");\n            // No ordenamos en la consulta para evitar problemas de índices compuestos\n            // Ordenaremos en memoria después\n            let q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(rafflesRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"shopId\", \"==\", shopId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.ACTIVE));\n            const allDocs = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            let raffles = [];\n            for (const docSnap of allDocs.docs){\n                const raffle = await convertRaffleDoc(docSnap);\n                raffles.push(raffle);\n            }\n            // Aplicar búsqueda si existe\n            if (filters === null || filters === void 0 ? void 0 : filters.search) {\n                const searchLower = filters.search.toLowerCase();\n                raffles = raffles.filter((r)=>{\n                    var _r_product, _r_product1;\n                    return ((_r_product = r.product) === null || _r_product === void 0 ? void 0 : _r_product.name.toLowerCase().includes(searchLower)) || ((_r_product1 = r.product) === null || _r_product1 === void 0 ? void 0 : _r_product1.description.toLowerCase().includes(searchLower));\n                });\n            }\n            // Ordenar en memoria\n            if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"newest\") {\n                raffles.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n            } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"closest\") {\n                raffles.sort((a, b)=>b.soldTickets - a.soldTickets);\n            } else {\n                raffles.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n            }\n            // Paginación\n            const pageSize1 = (filters === null || filters === void 0 ? void 0 : filters.limit) || 12;\n            const page1 = (filters === null || filters === void 0 ? void 0 : filters.page) || 1;\n            const offset1 = (page1 - 1) * pageSize1;\n            const total = raffles.length;\n            const totalPages = Math.ceil(total / pageSize1);\n            const paginatedRaffles = raffles.slice(offset1, offset1 + pageSize1);\n            return {\n                data: paginatedRaffles,\n                total,\n                page: page1,\n                limit: pageSize1,\n                totalPages\n            };\n        } catch (error) {\n            console.error(\"Error fetching shop raffles:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Obtiene categorías disponibles para filtrar\n   */ async getCategories () {\n        try {\n            const productsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"products\");\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(productsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", \"active\"));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const categories = new Set();\n            snapshot.docs.forEach((doc)=>{\n                const data = doc.data();\n                if (data.category) {\n                    categories.add(data.category);\n                }\n            });\n            return Array.from(categories).sort();\n        } catch (error) {\n            console.error(\"Error fetching categories:\", error);\n            return [];\n        }\n    },\n    /**\n   * Obtiene tiendas con sorteos activos\n   */ async getShopsWithActiveRaffles () {\n        try {\n            const rafflesRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"raffles\");\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(rafflesRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.ACTIVE));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const shopIds = new Set();\n            snapshot.docs.forEach((doc)=>{\n                const data = doc.data();\n                if (data.shopId) {\n                    shopIds.add(data.shopId);\n                }\n            });\n            // Obtener información de las tiendas\n            const shops = [];\n            for (const shopId of shopIds){\n                try {\n                    const shopDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"shops\", shopId));\n                    if (shopDoc.exists()) {\n                        const shopData = shopDoc.data();\n                        shops.push({\n                            id: shopDoc.id,\n                            name: shopData.name || \"Tienda sin nombre\"\n                        });\n                    }\n                } catch (error) {\n                    console.error(\"Error loading shop \".concat(shopId, \":\"), error);\n                }\n            }\n            return shops.sort((a, b)=>a.name.localeCompare(b.name));\n        } catch (error) {\n            console.error(\"Error fetching shops:\", error);\n            return [];\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9maXJlYmFzZS1yYWZmbGUtc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBVTRCO0FBQ1E7QUFDa0I7QUF3QnRELG1EQUFtRDtBQUNuRCxNQUFNUyxtQkFBbUIsQ0FBQ0M7SUFDeEIsSUFBSUEsc0JBQUFBLGdDQUFBQSxVQUFXQyxNQUFNLEVBQUU7UUFDckIsT0FBT0QsVUFBVUMsTUFBTTtJQUN6QjtJQUNBLElBQUlELHFCQUFxQkUsTUFBTTtRQUM3QixPQUFPRjtJQUNUO0lBQ0EsSUFBSSxPQUFPQSxjQUFjLFVBQVU7UUFDakMsT0FBTyxJQUFJRSxLQUFLRjtJQUNsQjtJQUNBLE9BQU8sSUFBSUU7QUFDYjtBQUVBLHdEQUF3RDtBQUN4RCxNQUFNQyxtQkFBbUIsT0FBT0M7SUFDOUIsTUFBTUMsT0FBT0QsUUFBUUMsSUFBSTtJQUN6QixNQUFNQyxTQUFpQjtRQUNyQkMsSUFBSUgsUUFBUUcsRUFBRTtRQUNkQyxRQUFRSCxLQUFLRyxNQUFNLElBQUk7UUFDdkJDLFdBQVdKLEtBQUtJLFNBQVMsSUFBSTtRQUM3QkMsY0FBY0wsS0FBS0ssWUFBWSxJQUFJO1FBQ25DQyxjQUFjTixLQUFLTSxZQUFZLElBQUk7UUFDbkNDLGFBQWFQLEtBQUtPLFdBQVcsSUFBSTtRQUNqQ0MsUUFBUVIsS0FBS1EsTUFBTSxJQUFJZix1REFBWUEsQ0FBQ2dCLEtBQUs7UUFDekNDLGlCQUFpQlYsS0FBS1UsZUFBZSxJQUFJO1FBQ3pDQyxnQkFBZ0JYLEtBQUtXLGNBQWM7UUFDbkNDLG1CQUFtQlosS0FBS1ksaUJBQWlCO1FBQ3pDQyxXQUFXbkIsaUJBQWlCTSxLQUFLYSxTQUFTO1FBQzFDQyxXQUFXcEIsaUJBQWlCTSxLQUFLYyxTQUFTO1FBQzFDQyxhQUFhZixLQUFLZSxXQUFXLEdBQUdyQixpQkFBaUJNLEtBQUtlLFdBQVcsSUFBSUM7UUFDckVDLGtCQUFrQmpCLEtBQUtpQixnQkFBZ0IsR0FBR3ZCLGlCQUFpQk0s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LElBQUllLFFBQVFDLE1BQU0sSUFBSTt3QkFDcEIsTUFBTUMsV0FBV0YsUUFBUWxCLElBQUk7d0JBQzdCK0YsTUFBTXJDLElBQUksQ0FBQzs0QkFDVHhELElBQUlnQixRQUFRaEIsRUFBRTs0QkFDZHFCLE1BQU1ILFNBQVNHLElBQUksSUFBSTt3QkFDekI7b0JBQ0Y7Z0JBQ0YsRUFBRSxPQUFPTSxPQUFPO29CQUNkQyxRQUFRRCxLQUFLLENBQUMsc0JBQTZCLE9BQVAxQixRQUFPLE1BQUkwQjtnQkFDakQ7WUFDRjtZQUVBLE9BQU9rRSxNQUFNN0IsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUU1QyxJQUFJLENBQUN5RSxhQUFhLENBQUM1QixFQUFFN0MsSUFBSTtRQUN6RCxFQUFFLE9BQU9NLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkMsT0FBTyxFQUFFO1FBQ1g7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL2ZpcmViYXNlLXJhZmZsZS1zZXJ2aWNlLnRzP2RhZGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgY29sbGVjdGlvbixcbiAgcXVlcnksXG4gIHdoZXJlLFxuICBnZXREb2NzLFxuICBnZXREb2MsXG4gIGRvYyxcbiAgb3JkZXJCeSxcbiAgUXVlcnlEb2N1bWVudFNuYXBzaG90LFxuICBEb2N1bWVudERhdGEsXG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJ0AvbGliL2ZpcmViYXNlJztcbmltcG9ydCB7IFJhZmZsZSwgUmFmZmxlU3RhdHVzIH0gZnJvbSAnQC90eXBlcy9yYWZmbGUnO1xuaW1wb3J0IHsgUHJvZHVjdCB9IGZyb20gJ0AvdHlwZXMvcHJvZHVjdCc7XG5pbXBvcnQgeyBTaG9wIH0gZnJvbSAnQC90eXBlcy9zaG9wJztcblxuZXhwb3J0IGludGVyZmFjZSBSYWZmbGVGaWx0ZXJzIHtcbiAgY2F0ZWdvcnk/OiBzdHJpbmc7XG4gIHNob3BJZD86IHN0cmluZztcbiAgc3RhdHVzPzogc3RyaW5nO1xuICBtaW5WYWx1ZT86IG51bWJlcjtcbiAgbWF4VmFsdWU/OiBudW1iZXI7XG4gIHNlYXJjaD86IHN0cmluZztcbiAgc29ydEJ5PzogJ25ld2VzdCcgfCAnY2xvc2VzdCcgfCAncHJpY2UtYXNjJyB8ICdwcmljZS1kZXNjJztcbiAgcGFnZT86IG51bWJlcjtcbiAgbGltaXQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnaW5hdGVkUmFmZmxlcyB7XG4gIGRhdGE6IFJhZmZsZVtdO1xuICB0b3RhbDogbnVtYmVyO1xuICBwYWdlOiBudW1iZXI7XG4gIGxpbWl0OiBudW1iZXI7XG4gIHRvdGFsUGFnZXM6IG51bWJlcjtcbn1cblxuLy8gSGVscGVyIHBhcmEgY29udmVydGlyIEZpcmVzdG9yZSB0aW1lc3RhbXAgYSBEYXRlXG5jb25zdCBjb252ZXJ0VGltZXN0YW1wID0gKHRpbWVzdGFtcDogYW55KTogRGF0ZSA9PiB7XG4gIGlmICh0aW1lc3RhbXA/LnRvRGF0ZSkge1xuICAgIHJldHVybiB0aW1lc3RhbXAudG9EYXRlKCk7XG4gIH1cbiAgaWYgKHRpbWVzdGFtcCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gdGltZXN0YW1wO1xuICB9XG4gIGlmICh0eXBlb2YgdGltZXN0YW1wID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXApO1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZSgpO1xufTtcblxuLy8gSGVscGVyIHBhcmEgY29udmVydGlyIGRvY3VtZW50byBkZSBGaXJlc3RvcmUgYSBSYWZmbGVcbmNvbnN0IGNvbnZlcnRSYWZmbGVEb2MgPSBhc3luYyAoZG9jU25hcDogUXVlcnlEb2N1bWVudFNuYXBzaG90PERvY3VtZW50RGF0YT4pOiBQcm9taXNlPFJhZmZsZT4gPT4ge1xuICBjb25zdCBkYXRhID0gZG9jU25hcC5kYXRhKCk7XG4gIGNvbnN0IHJhZmZsZTogUmFmZmxlID0ge1xuICAgIGlkOiBkb2NTbmFwLmlkLFxuICAgIHNob3BJZDogZGF0YS5zaG9wSWQgfHwgJycsXG4gICAgcHJvZHVjdElkOiBkYXRhLnByb2R1Y3RJZCB8fCAnJyxcbiAgICBwcm9kdWN0VmFsdWU6IGRhdGEucHJvZHVjdFZhbHVlIHx8IDAsXG4gICAgdG90YWxUaWNrZXRzOiBkYXRhLnRvdGFsVGlja2V0cyB8fCAwLFxuICAgIHNvbGRUaWNrZXRzOiBkYXRhLnNvbGRUaWNrZXRzIHx8IDAsXG4gICAgc3RhdHVzOiBkYXRhLnN0YXR1cyB8fCBSYWZmbGVTdGF0dXMuRFJBRlQsXG4gICAgcmVxdWlyZXNEZXBvc2l0OiBkYXRhLnJlcXVpcmVzRGVwb3NpdCB8fCBmYWxzZSxcbiAgICB3aW5uZXJUaWNrZXRJZDogZGF0YS53aW5uZXJUaWNrZXRJZCxcbiAgICBzcGVjaWFsQ29uZGl0aW9uczogZGF0YS5zcGVjaWFsQ29uZGl0aW9ucyxcbiAgICBjcmVhdGVkQXQ6IGNvbnZlcnRUaW1lc3RhbXAoZGF0YS5jcmVhdGVkQXQpLFxuICAgIHVwZGF0ZWRBdDogY29udmVydFRpbWVzdGFtcChkYXRhLnVwZGF0ZWRBdCksXG4gICAgYWN0aXZhdGVkQXQ6IGRhdGEuYWN0aXZhdGVkQXQgPyBjb252ZXJ0VGltZXN0YW1wKGRhdGEuYWN0aXZhdGVkQXQpIDogdW5kZWZpbmVkLFxuICAgIHJhZmZsZUV4ZWN1dGVkQXQ6IGRhdGEucmFmZmxlRXhlY3V0ZWRBdCA/IGNvbnZlcnRUaW1lc3RhbXAoZGF0YS5yYWZmbGVFeGVjdXRlZEF0KSA6IHVuZGVmaW5lZCxcbiAgfTtcblxuICAvLyBDYXJnYXIgcmVsYWNpb25lcyBzaSBleGlzdGVuXG4gIGlmIChkYXRhLnNob3BJZCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzaG9wRG9jID0gYXdhaXQgZ2V0RG9jKGRvYyhkYiwgJ3Nob3BzJywgZGF0YS5zaG9wSWQpKTtcbiAgICAgIGlmIChzaG9wRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIGNvbnN0IHNob3BEYXRhID0gc2hvcERvYy5kYXRhKCk7XG4gICAgICAgIHJhZmZsZS5zaG9wID0ge1xuICAgICAgICAgIGlkOiBzaG9wRG9jLmlkLFxuICAgICAgICAgIHVzZXJJZDogc2hvcERhdGEudXNlcklkIHx8ICcnLFxuICAgICAgICAgIG5hbWU6IHNob3BEYXRhLm5hbWUgfHwgJycsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHNob3BEYXRhLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIGxvZ286IHNob3BEYXRhLmxvZ28sXG4gICAgICAgICAgcHVibGljRW1haWw6IHNob3BEYXRhLnB1YmxpY0VtYWlsLFxuICAgICAgICAgIHBob25lOiBzaG9wRGF0YS5waG9uZSxcbiAgICAgICAgICBzb2NpYWxNZWRpYTogc2hvcERhdGEuc29jaWFsTWVkaWEsXG4gICAgICAgICAgc3RhdHVzOiBzaG9wRGF0YS5zdGF0dXMgfHwgJ3BlbmRpbmcnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogY29udmVydFRpbWVzdGFtcChzaG9wRGF0YS5jcmVhdGVkQXQpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogY29udmVydFRpbWVzdGFtcChzaG9wRGF0YS51cGRhdGVkQXQpLFxuICAgICAgICB9IGFzIFNob3A7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2hvcDonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRhdGEucHJvZHVjdElkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb2R1Y3REb2MgPSBhd2FpdCBnZXREb2MoZG9jKGRiLCAncHJvZHVjdHMnLCBkYXRhLnByb2R1Y3RJZCkpO1xuICAgICAgaWYgKHByb2R1Y3REb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgY29uc3QgcHJvZHVjdERhdGEgPSBwcm9kdWN0RG9jLmRhdGEoKTtcbiAgICAgICAgcmFmZmxlLnByb2R1Y3QgPSB7XG4gICAgICAgICAgaWQ6IHByb2R1Y3REb2MuaWQsXG4gICAgICAgICAgc2hvcElkOiBwcm9kdWN0RGF0YS5zaG9wSWQgfHwgJycsXG4gICAgICAgICAgbmFtZTogcHJvZHVjdERhdGEubmFtZSB8fCAnJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogcHJvZHVjdERhdGEuZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgICAgdmFsdWU6IHByb2R1Y3REYXRhLnZhbHVlIHx8IDAsXG4gICAgICAgICAgaGVpZ2h0OiBwcm9kdWN0RGF0YS5oZWlnaHQgfHwgMCxcbiAgICAgICAgICB3aWR0aDogcHJvZHVjdERhdGEud2lkdGggfHwgMCxcbiAgICAgICAgICBkZXB0aDogcHJvZHVjdERhdGEuZGVwdGggfHwgMCxcbiAgICAgICAgICByZXF1aXJlc0RlcG9zaXQ6IHByb2R1Y3REYXRhLnJlcXVpcmVzRGVwb3NpdCB8fCBmYWxzZSxcbiAgICAgICAgICBjYXRlZ29yeTogcHJvZHVjdERhdGEuY2F0ZWdvcnksXG4gICAgICAgICAgbWFpbkltYWdlOiBwcm9kdWN0RGF0YS5tYWluSW1hZ2UsXG4gICAgICAgICAgc3RhdHVzOiBwcm9kdWN0RGF0YS5zdGF0dXMgfHwgJ2luYWN0aXZlJyxcbiAgICAgICAgICBjcmVhdGVkQXQ6IGNvbnZlcnRUaW1lc3RhbXAocHJvZHVjdERhdGEuY3JlYXRlZEF0KSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IGNvbnZlcnRUaW1lc3RhbXAocHJvZHVjdERhdGEudXBkYXRlZEF0KSxcbiAgICAgICAgfSBhcyBQcm9kdWN0O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHByb2R1Y3Q6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByYWZmbGU7XG59O1xuXG5leHBvcnQgY29uc3QgZmlyZWJhc2VSYWZmbGVTZXJ2aWNlID0ge1xuICAvKipcbiAgICogT2J0aWVuZSBzb3J0ZW9zIGFjdGl2b3MgY29uIGZpbHRyb3MgeSBiw7pzcXVlZGFcbiAgICovXG4gIGFzeW5jIGdldEFjdGl2ZVJhZmZsZXMoZmlsdGVycz86IFJhZmZsZUZpbHRlcnMpOiBQcm9taXNlPFBhZ2luYXRlZFJhZmZsZXM+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmFmZmxlc1JlZiA9IGNvbGxlY3Rpb24oZGIsICdyYWZmbGVzJyk7XG4gICAgICBcbiAgICAgIC8vIEludGVudGFyIGNvbnN1bHRhIGNvbiBmaWx0cm8gZGUgc3RhdHVzLCBwZXJvIHNpIGZhbGxhIHBvciDDrW5kaWNlLCBvYnRlbmVyIHRvZG9zIHkgZmlsdHJhclxuICAgICAgbGV0IGFsbERvY3M7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgcSA9IHF1ZXJ5KHJhZmZsZXNSZWYsIHdoZXJlKCdzdGF0dXMnLCAnPT0nLCBSYWZmbGVTdGF0dXMuQUNUSVZFKSk7XG5cbiAgICAgICAgLy8gQXBsaWNhciBmaWx0cm9zIGFkaWNpb25hbGVzXG4gICAgICAgIGlmIChmaWx0ZXJzPy5zaG9wSWQpIHtcbiAgICAgICAgICBxID0gcXVlcnkocSwgd2hlcmUoJ3Nob3BJZCcsICc9PScsIGZpbHRlcnMuc2hvcElkKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlbnRhciBvcmRlbmFyIHNpIG5vIGhheSBmaWx0cm8gZGUgc2hvcElkIChwYXJhIGV2aXRhciBwcm9ibGVtYXMgZGUgw61uZGljZXMgY29tcHVlc3RvcylcbiAgICAgICAgaWYgKCFmaWx0ZXJzPy5zaG9wSWQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGZpbHRlcnM/LnNvcnRCeSA9PT0gJ25ld2VzdCcpIHtcbiAgICAgICAgICAgICAgcSA9IHF1ZXJ5KHEsIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXJzPy5zb3J0QnkgPT09ICdjbG9zZXN0Jykge1xuICAgICAgICAgICAgICBxID0gcXVlcnkocSwgb3JkZXJCeSgnc29sZFRpY2tldHMnLCAnZGVzYycpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsdGVycz8uc29ydEJ5ID09PSAncHJpY2UtYXNjJykge1xuICAgICAgICAgICAgICBxID0gcXVlcnkocSwgb3JkZXJCeSgncHJvZHVjdFZhbHVlJywgJ2FzYycpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsdGVycz8uc29ydEJ5ID09PSAncHJpY2UtZGVzYycpIHtcbiAgICAgICAgICAgICAgcSA9IHF1ZXJ5KHEsIG9yZGVyQnkoJ3Byb2R1Y3RWYWx1ZScsICdkZXNjJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcSA9IHF1ZXJ5KHEsIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsRG9jcyA9IGF3YWl0IGdldERvY3MocSk7XG4gICAgICAgICAgfSBjYXRjaCAob3JkZXJFcnJvcjogYW55KSB7XG4gICAgICAgICAgICAvLyBTaSBmYWxsYSBlbCBvcmRlckJ5LCBpbnRlbnRhciBzaW4gb3JkZW5hclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciBjb24gb3JkZXJCeSwgb2J0ZW5pZW5kbyBzaW4gb3JkZW5hcjonLCBvcmRlckVycm9yKTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJzPy5zaG9wSWQpIHtcbiAgICAgICAgICAgICAgcSA9IHF1ZXJ5KHJhZmZsZXNSZWYsIHdoZXJlKCdzdGF0dXMnLCAnPT0nLCBSYWZmbGVTdGF0dXMuQUNUSVZFKSwgd2hlcmUoJ3Nob3BJZCcsICc9PScsIGZpbHRlcnMuc2hvcElkKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBxID0gcXVlcnkocmFmZmxlc1JlZiwgd2hlcmUoJ3N0YXR1cycsICc9PScsIFJhZmZsZVN0YXR1cy5BQ1RJVkUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsbERvY3MgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGxEb2NzID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAocXVlcnlFcnJvcjogYW55KSB7XG4gICAgICAgIC8vIFNpIGZhbGxhIGxhIGNvbnN1bHRhIGNvbiB3aGVyZSwgb2J0ZW5lciB0b2RvcyB5IGZpbHRyYXIgZW4gbWVtb3JpYVxuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGVuIGNvbnN1bHRhIGNvbiB3aGVyZSwgb2J0ZW5pZW5kbyB0b2RvcyBsb3Mgc29ydGVvczonLCBxdWVyeUVycm9yKTtcbiAgICAgICAgY29uc3QgYWxsUmFmZmxlc1F1ZXJ5ID0gcXVlcnkocmFmZmxlc1JlZik7XG4gICAgICAgIGNvbnN0IGFsbFJhZmZsZXNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoYWxsUmFmZmxlc1F1ZXJ5KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZpbHRyYXIgcG9yIHN0YXR1cyBhY3Rpdm8gZW4gbWVtb3JpYVxuICAgICAgICBhbGxEb2NzID0ge1xuICAgICAgICAgIGRvY3M6IGFsbFJhZmZsZXNTbmFwc2hvdC5kb2NzLmZpbHRlcihkb2MgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZG9jLmRhdGEoKS5zdGF0dXM7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzID09PSBSYWZmbGVTdGF0dXMuQUNUSVZFIHx8IHN0YXR1cyA9PT0gJ2FjdGl2ZSc7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSBhcyBhbnk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBTb3J0ZW9zIGFjdGl2b3MgZW5jb250cmFkb3MgZGVzcHXDqXMgZGUgZmlsdHJhcjogJHthbGxEb2NzLmRvY3MubGVuZ3RofSBkZSAke2FsbFJhZmZsZXNTbmFwc2hvdC5kb2NzLmxlbmd0aH0gdG90YWxlc2ApO1xuICAgICAgfVxuXG4gICAgICBsZXQgcmFmZmxlczogUmFmZmxlW10gPSBbXTtcblxuICAgICAgLy8gQ29udmVydGlyIGRvY3VtZW50b3NcbiAgICAgIGZvciAoY29uc3QgZG9jU25hcCBvZiBhbGxEb2NzLmRvY3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByYWZmbGUgPSBhd2FpdCBjb252ZXJ0UmFmZmxlRG9jKGRvY1NuYXApO1xuICAgICAgICAgIHJhZmZsZXMucHVzaChyYWZmbGUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbnZlcnRpbmcgcmFmZmxlIGRvYzonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYOKchSBTb3J0ZW9zIGFjdGl2b3MgY2FyZ2Fkb3M6ICR7cmFmZmxlcy5sZW5ndGh9YCk7XG5cbiAgICAgIC8vIEFwbGljYXIgZmlsdHJvcyBxdWUgcmVxdWllcmVuIGxvcyBkYXRvcyBjb21wbGV0b3NcbiAgICAgIGlmIChmaWx0ZXJzPy5jYXRlZ29yeSkge1xuICAgICAgICByYWZmbGVzID0gcmFmZmxlcy5maWx0ZXIoKHIpID0+IHIucHJvZHVjdD8uY2F0ZWdvcnkgPT09IGZpbHRlcnMuY2F0ZWdvcnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlsdGVycz8ubWluVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByYWZmbGVzID0gcmFmZmxlcy5maWx0ZXIoKHIpID0+IHIucHJvZHVjdFZhbHVlID49IGZpbHRlcnMubWluVmFsdWUhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbHRlcnM/Lm1heFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmFmZmxlcyA9IHJhZmZsZXMuZmlsdGVyKChyKSA9PiByLnByb2R1Y3RWYWx1ZSA8PSBmaWx0ZXJzLm1heFZhbHVlISk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXJzPy5zZWFyY2gpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoTG93ZXIgPSBmaWx0ZXJzLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByYWZmbGVzID0gcmFmZmxlcy5maWx0ZXIoXG4gICAgICAgICAgKHIpID0+XG4gICAgICAgICAgICByLnByb2R1Y3Q/Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcikgfHxcbiAgICAgICAgICAgIHIucHJvZHVjdD8uZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcikgfHxcbiAgICAgICAgICAgIHIuc2hvcD8ubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaExvd2VyKSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gT3JkZW5hciBlbiBtZW1vcmlhIHNpIGhheSBmaWx0cm8gZGUgc2hvcElkIG8gc2kgbm8gc2UgcHVkbyBvcmRlbmFyIGVuIGxhIGNvbnN1bHRhXG4gICAgICBpZiAoZmlsdGVycz8uc2hvcElkIHx8IGZpbHRlcnM/LnNvcnRCeSkge1xuICAgICAgICBpZiAoZmlsdGVycz8uc29ydEJ5ID09PSAnbmV3ZXN0Jykge1xuICAgICAgICAgIHJhZmZsZXMuc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkQXQuZ2V0VGltZSgpIC0gYS5jcmVhdGVkQXQuZ2V0VGltZSgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXJzPy5zb3J0QnkgPT09ICdjbG9zZXN0Jykge1xuICAgICAgICAgIHJhZmZsZXMuc29ydCgoYSwgYikgPT4gYi5zb2xkVGlja2V0cyAtIGEuc29sZFRpY2tldHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbHRlcnM/LnNvcnRCeSA9PT0gJ3ByaWNlLWFzYycpIHtcbiAgICAgICAgICByYWZmbGVzLnNvcnQoKGEsIGIpID0+IGEucHJvZHVjdFZhbHVlIC0gYi5wcm9kdWN0VmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbHRlcnM/LnNvcnRCeSA9PT0gJ3ByaWNlLWRlc2MnKSB7XG4gICAgICAgICAgcmFmZmxlcy5zb3J0KChhLCBiKSA9PiBiLnByb2R1Y3RWYWx1ZSAtIGEucHJvZHVjdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBcGxpY2FyIHBhZ2luYWNpw7NuIG1hbnVhbFxuICAgICAgY29uc3QgdG90YWwgPSByYWZmbGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHRvdGFsUGFnZXMgPSBNYXRoLmNlaWwodG90YWwgLyBwYWdlU2l6ZSk7XG4gICAgICBjb25zdCBwYWdpbmF0ZWRSYWZmbGVzID0gcmFmZmxlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHBhZ2VTaXplKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGFnaW5hdGVkUmFmZmxlcyxcbiAgICAgICAgdG90YWwsXG4gICAgICAgIHBhZ2UsXG4gICAgICAgIGxpbWl0OiBwYWdlU2l6ZSxcbiAgICAgICAgdG90YWxQYWdlcyxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGFjdGl2ZSByYWZmbGVzOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogT2J0aWVuZSB1biBzb3J0ZW8gZXNwZWPDrWZpY28gcG9yIElEIChww7pibGljbylcbiAgICovXG4gIGFzeW5jIGdldFJhZmZsZUJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8UmFmZmxlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhZmZsZURvYyA9IGF3YWl0IGdldERvYyhkb2MoZGIsICdyYWZmbGVzJywgaWQpKTtcbiAgICAgIGlmICghcmFmZmxlRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmFmZmxlIG5vdCBmb3VuZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IGNvbnZlcnRSYWZmbGVEb2MocmFmZmxlRG9jIGFzIFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdDxEb2N1bWVudERhdGE+KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmFmZmxlOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogT2J0aWVuZSBzb3J0ZW9zIGRlIHVuYSB0aWVuZGEgZXNwZWPDrWZpY2EgKHDDumJsaWNvKVxuICAgKi9cbiAgYXN5bmMgZ2V0UmFmZmxlc0J5U2hvcChzaG9wSWQ6IHN0cmluZywgZmlsdGVycz86IE9taXQ8UmFmZmxlRmlsdGVycywgJ3Nob3BJZCc+KTogUHJvbWlzZTxQYWdpbmF0ZWRSYWZmbGVzPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhZmZsZXNSZWYgPSBjb2xsZWN0aW9uKGRiLCAncmFmZmxlcycpO1xuICAgICAgLy8gTm8gb3JkZW5hbW9zIGVuIGxhIGNvbnN1bHRhIHBhcmEgZXZpdGFyIHByb2JsZW1hcyBkZSDDrW5kaWNlcyBjb21wdWVzdG9zXG4gICAgICAvLyBPcmRlbmFyZW1vcyBlbiBtZW1vcmlhIGRlc3B1w6lzXG4gICAgICBsZXQgcSA9IHF1ZXJ5KHJhZmZsZXNSZWYsIHdoZXJlKCdzaG9wSWQnLCAnPT0nLCBzaG9wSWQpLCB3aGVyZSgnc3RhdHVzJywgJz09JywgUmFmZmxlU3RhdHVzLkFDVElWRSkpO1xuXG4gICAgICBjb25zdCBhbGxEb2NzID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICAgIGxldCByYWZmbGVzOiBSYWZmbGVbXSA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IGRvY1NuYXAgb2YgYWxsRG9jcy5kb2NzKSB7XG4gICAgICAgIGNvbnN0IHJhZmZsZSA9IGF3YWl0IGNvbnZlcnRSYWZmbGVEb2MoZG9jU25hcCk7XG4gICAgICAgIHJhZmZsZXMucHVzaChyYWZmbGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBcGxpY2FyIGLDunNxdWVkYSBzaSBleGlzdGVcbiAgICAgIGlmIChmaWx0ZXJzPy5zZWFyY2gpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoTG93ZXIgPSBmaWx0ZXJzLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByYWZmbGVzID0gcmFmZmxlcy5maWx0ZXIoXG4gICAgICAgICAgKHIpID0+XG4gICAgICAgICAgICByLnByb2R1Y3Q/Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcikgfHxcbiAgICAgICAgICAgIHIucHJvZHVjdD8uZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlciksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIE9yZGVuYXIgZW4gbWVtb3JpYVxuICAgICAgaWYgKGZpbHRlcnM/LnNvcnRCeSA9PT0gJ25ld2VzdCcpIHtcbiAgICAgICAgcmFmZmxlcy5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRBdC5nZXRUaW1lKCkgLSBhLmNyZWF0ZWRBdC5nZXRUaW1lKCkpO1xuICAgICAgfSBlbHNlIGlmIChmaWx0ZXJzPy5zb3J0QnkgPT09ICdjbG9zZXN0Jykge1xuICAgICAgICByYWZmbGVzLnNvcnQoKGEsIGIpID0+IGIuc29sZFRpY2tldHMgLSBhLnNvbGRUaWNrZXRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhZmZsZXMuc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkQXQuZ2V0VGltZSgpIC0gYS5jcmVhdGVkQXQuZ2V0VGltZSgpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUGFnaW5hY2nDs25cbiAgICAgIGNvbnN0IHBhZ2VTaXplID0gZmlsdGVycz8ubGltaXQgfHwgMTI7XG4gICAgICBjb25zdCBwYWdlID0gZmlsdGVycz8ucGFnZSB8fCAxO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKHBhZ2UgLSAxKSAqIHBhZ2VTaXplO1xuICAgICAgY29uc3QgdG90YWwgPSByYWZmbGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHRvdGFsUGFnZXMgPSBNYXRoLmNlaWwodG90YWwgLyBwYWdlU2l6ZSk7XG4gICAgICBjb25zdCBwYWdpbmF0ZWRSYWZmbGVzID0gcmFmZmxlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHBhZ2VTaXplKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGFnaW5hdGVkUmFmZmxlcyxcbiAgICAgICAgdG90YWwsXG4gICAgICAgIHBhZ2UsXG4gICAgICAgIGxpbWl0OiBwYWdlU2l6ZSxcbiAgICAgICAgdG90YWxQYWdlcyxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNob3AgcmFmZmxlczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9idGllbmUgY2F0ZWdvcsOtYXMgZGlzcG9uaWJsZXMgcGFyYSBmaWx0cmFyXG4gICAqL1xuICBhc3luYyBnZXRDYXRlZ29yaWVzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvZHVjdHNSZWYgPSBjb2xsZWN0aW9uKGRiLCAncHJvZHVjdHMnKTtcbiAgICAgIGNvbnN0IHEgPSBxdWVyeShwcm9kdWN0c1JlZiwgd2hlcmUoJ3N0YXR1cycsICc9PScsICdhY3RpdmUnKSk7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG5cbiAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgIHNuYXBzaG90LmRvY3MuZm9yRWFjaCgoZG9jKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xuICAgICAgICBpZiAoZGF0YS5jYXRlZ29yeSkge1xuICAgICAgICAgIGNhdGVnb3JpZXMuYWRkKGRhdGEuY2F0ZWdvcnkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2F0ZWdvcmllcykuc29ydCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjYXRlZ29yaWVzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9idGllbmUgdGllbmRhcyBjb24gc29ydGVvcyBhY3Rpdm9zXG4gICAqL1xuICBhc3luYyBnZXRTaG9wc1dpdGhBY3RpdmVSYWZmbGVzKCk6IFByb21pc2U8QXJyYXk8eyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfT4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmFmZmxlc1JlZiA9IGNvbGxlY3Rpb24oZGIsICdyYWZmbGVzJyk7XG4gICAgICBjb25zdCBxID0gcXVlcnkocmFmZmxlc1JlZiwgd2hlcmUoJ3N0YXR1cycsICc9PScsIFJhZmZsZVN0YXR1cy5BQ1RJVkUpKTtcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcblxuICAgICAgY29uc3Qgc2hvcElkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgc25hcHNob3QuZG9jcy5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XG4gICAgICAgIGlmIChkYXRhLnNob3BJZCkge1xuICAgICAgICAgIHNob3BJZHMuYWRkKGRhdGEuc2hvcElkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIE9idGVuZXIgaW5mb3JtYWNpw7NuIGRlIGxhcyB0aWVuZGFzXG4gICAgICBjb25zdCBzaG9wczogQXJyYXk8eyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfT4gPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc2hvcElkIG9mIHNob3BJZHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzaG9wRG9jID0gYXdhaXQgZ2V0RG9jKGRvYyhkYiwgJ3Nob3BzJywgc2hvcElkKSk7XG4gICAgICAgICAgaWYgKHNob3BEb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNob3BEYXRhID0gc2hvcERvYy5kYXRhKCk7XG4gICAgICAgICAgICBzaG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IHNob3BEb2MuaWQsXG4gICAgICAgICAgICAgIG5hbWU6IHNob3BEYXRhLm5hbWUgfHwgJ1RpZW5kYSBzaW4gbm9tYnJlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nIHNob3AgJHtzaG9wSWR9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvcHMuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNob3BzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0sXG59O1xuXG4iXSwibmFtZXMiOlsiY29sbGVjdGlvbiIsInF1ZXJ5Iiwid2hlcmUiLCJnZXREb2NzIiwiZ2V0RG9jIiwiZG9jIiwib3JkZXJCeSIsImRiIiwiUmFmZmxlU3RhdHVzIiwiY29udmVydFRpbWVzdGFtcCIsInRpbWVzdGFtcCIsInRvRGF0ZSIsIkRhdGUiLCJjb252ZXJ0UmFmZmxlRG9jIiwiZG9jU25hcCIsImRhdGEiLCJyYWZmbGUiLCJpZCIsInNob3BJZCIsInByb2R1Y3RJZCIsInByb2R1Y3RWYWx1ZSIsInRvdGFsVGlja2V0cyIsInNvbGRUaWNrZXRzIiwic3RhdHVzIiwiRFJBRlQiLCJyZXF1aXJlc0RlcG9zaXQiLCJ3aW5uZXJUaWNrZXRJZCIsInNwZWNpYWxDb25kaXRpb25zIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwiYWN0aXZhdGVkQXQiLCJ1bmRlZmluZWQiLCJyYWZmbGVFeGVjdXRlZEF0Iiwic2hvcERvYyIsImV4aXN0cyIsInNob3BEYXRhIiwic2hvcCIsInVzZXJJZCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImxvZ28iLCJwdWJsaWNFbWFpbCIsInBob25lIiwic29jaWFsTWVkaWEiLCJlcnJvciIsImNvbnNvbGUiLCJwcm9kdWN0RG9jIiwicHJvZHVjdERhdGEiLCJwcm9kdWN0IiwidmFsdWUiLCJoZWlnaHQiLCJ3aWR0aCIsImRlcHRoIiwiY2F0ZWdvcnkiLCJtYWluSW1hZ2UiLCJmaXJlYmFzZVJhZmZsZVNlcnZpY2UiLCJnZXRBY3RpdmVSYWZmbGVzIiwiZmlsdGVycyIsInJhZmZsZXNSZWYiLCJhbGxEb2NzIiwicSIsIkFDVElWRSIsInNvcnRCeSIsIm9yZGVyRXJyb3IiLCJ3YXJuIiwicXVlcnlFcnJvciIsImFsbFJhZmZsZXNRdWVyeSIsImFsbFJhZmZsZXNTbmFwc2hvdCIsImRvY3MiLCJmaWx0ZXIiLCJsb2ciLCJsZW5ndGgiLCJyYWZmbGVzIiwicHVzaCIsInIiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwic2VhcmNoIiwic2VhcmNoTG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic29ydCIsImEiLCJiIiwiZ2V0VGltZSIsInRvdGFsIiwidG90YWxQYWdlcyIsIk1hdGgiLCJjZWlsIiwicGFnZVNpemUiLCJwYWdpbmF0ZWRSYWZmbGVzIiwic2xpY2UiLCJvZmZzZXQiLCJwYWdlIiwibGltaXQiLCJnZXRSYWZmbGVCeUlkIiwicmFmZmxlRG9jIiwiRXJyb3IiLCJnZXRSYWZmbGVzQnlTaG9wIiwiZ2V0Q2F0ZWdvcmllcyIsInByb2R1Y3RzUmVmIiwic25hcHNob3QiLCJjYXRlZ29yaWVzIiwiU2V0IiwiZm9yRWFjaCIsImFkZCIsIkFycmF5IiwiZnJvbSIsImdldFNob3BzV2l0aEFjdGl2ZVJhZmZsZXMiLCJzaG9wSWRzIiwic2hvcHMiLCJsb2NhbGVDb21wYXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/firebase-raffle-service.ts\n"));

/***/ })

});