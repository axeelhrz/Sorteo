"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_services_raffle-service_ts"],{

/***/ "(app-pages-browser)/./src/services/firebase-raffle-service.ts":
/*!*************************************************!*\
  !*** ./src/services/firebase-raffle-service.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   firebaseRaffleService: function() { return /* binding */ firebaseRaffleService; }\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/../node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* harmony import */ var _types_raffle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/types/raffle */ \"(app-pages-browser)/./src/types/raffle.ts\");\n\n\n\n// Helper para convertir Firestore timestamp a Date\nconst convertTimestamp = (timestamp)=>{\n    if (timestamp === null || timestamp === void 0 ? void 0 : timestamp.toDate) {\n        return timestamp.toDate();\n    }\n    if (timestamp instanceof Date) {\n        return timestamp;\n    }\n    if (typeof timestamp === \"string\") {\n        return new Date(timestamp);\n    }\n    return new Date();\n};\n// Helper para convertir documento de Firestore a Raffle\nconst convertRaffleDoc = async (docSnap)=>{\n    const data = docSnap.data();\n    const raffle = {\n        id: docSnap.id,\n        shopId: data.shopId || \"\",\n        productId: data.productId || \"\",\n        productValue: data.productValue || 0,\n        totalTickets: data.totalTickets || 0,\n        soldTickets: data.soldTickets || 0,\n        status: data.status || _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.DRAFT,\n        requiresDeposit: data.requiresDeposit || false,\n        winnerTicketId: data.winnerTicketId,\n        specialConditions: data.specialConditions,\n        createdAt: convertTimestamp(data.createdAt),\n        updatedAt: convertTimestamp(data.updatedAt),\n        activatedAt: data.activatedAt ? convertTimestamp(data.activatedAt) : undefined,\n        raffleExecutedAt: data.raffleExecutedAt ? convertTimestamp(data.raffleExecutedAt) : undefined\n    };\n    // Cargar relaciones si existen\n    if (data.shopId) {\n        try {\n            const shopDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"shops\", data.shopId));\n            if (shopDoc.exists()) {\n                const shopData = shopDoc.data();\n                raffle.shop = {\n                    id: shopDoc.id,\n                    userId: shopData.userId || \"\",\n                    name: shopData.name || \"\",\n                    description: shopData.description,\n                    logo: shopData.logo,\n                    publicEmail: shopData.publicEmail,\n                    phone: shopData.phone,\n                    socialMedia: shopData.socialMedia,\n                    status: shopData.status || \"pending\",\n                    createdAt: convertTimestamp(shopData.createdAt),\n                    updatedAt: convertTimestamp(shopData.updatedAt)\n                };\n            }\n        } catch (error) {\n            console.error(\"Error loading shop:\", error);\n        }\n    }\n    if (data.productId) {\n        try {\n            const productDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"products\", data.productId));\n            if (productDoc.exists()) {\n                const productData = productDoc.data();\n                raffle.product = {\n                    id: productDoc.id,\n                    shopId: productData.shopId || \"\",\n                    name: productData.name || \"\",\n                    description: productData.description || \"\",\n                    value: productData.value || 0,\n                    height: productData.height || 0,\n                    width: productData.width || 0,\n                    depth: productData.depth || 0,\n                    requiresDeposit: productData.requiresDeposit || false,\n                    category: productData.category,\n                    mainImage: productData.mainImage,\n                    status: productData.status || \"inactive\",\n                    createdAt: convertTimestamp(productData.createdAt),\n                    updatedAt: convertTimestamp(productData.updatedAt)\n                };\n            }\n        } catch (error) {\n            console.error(\"Error loading product:\", error);\n        }\n    }\n    return raffle;\n};\nconst firebaseRaffleService = {\n    /**\n   * Obtiene sorteos activos con filtros y búsqueda\n   */ async getActiveRaffles (filters) {\n        try {\n            const rafflesRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"raffles\");\n            // Intentar consulta con filtro de status, pero si falla por índice, obtener todos y filtrar\n            let allDocs;\n            try {\n                let q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(rafflesRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.ACTIVE));\n                // Aplicar filtros adicionales\n                if (filters === null || filters === void 0 ? void 0 : filters.shopId) {\n                    q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"shopId\", \"==\", filters.shopId));\n                }\n                // Intentar ordenar si no hay filtro de shopId (para evitar problemas de índices compuestos)\n                if (!(filters === null || filters === void 0 ? void 0 : filters.shopId)) {\n                    try {\n                        if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"newest\") {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"createdAt\", \"desc\"));\n                        } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"closest\") {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"soldTickets\", \"desc\"));\n                        } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"price-asc\") {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"productValue\", \"asc\"));\n                        } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"price-desc\") {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"productValue\", \"desc\"));\n                        } else {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"createdAt\", \"desc\"));\n                        }\n                        allDocs = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n                    } catch (orderError) {\n                        // Si falla el orderBy, intentar sin ordenar\n                        console.warn(\"Error con orderBy, obteniendo sin ordenar:\", orderError);\n                        if (filters === null || filters === void 0 ? void 0 : filters.shopId) {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(rafflesRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.ACTIVE), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"shopId\", \"==\", filters.shopId));\n                        } else {\n                            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(rafflesRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.ACTIVE));\n                        }\n                        allDocs = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n                    }\n                } else {\n                    allDocs = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n                }\n            } catch (queryError) {\n                // Si falla la consulta con where, obtener todos y filtrar en memoria\n                console.warn(\"Error en consulta con where, obteniendo todos los sorteos:\", queryError);\n                const allRafflesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(rafflesRef);\n                const allRafflesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(allRafflesQuery);\n                // Filtrar por status activo en memoria\n                allDocs = {\n                    docs: allRafflesSnapshot.docs.filter((doc)=>{\n                        const status = doc.data().status;\n                        return status === _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.ACTIVE || status === \"active\";\n                    })\n                };\n                console.log(\"\\uD83D\\uDCCA Sorteos activos encontrados despu\\xe9s de filtrar: \".concat(allDocs.docs.length, \" de \").concat(allRafflesSnapshot.docs.length, \" totales\"));\n            }\n            let raffles = [];\n            // Convertir documentos\n            for (const docSnap of allDocs.docs){\n                try {\n                    const raffle = await convertRaffleDoc(docSnap);\n                    raffles.push(raffle);\n                } catch (error) {\n                    console.error(\"Error converting raffle doc:\", error);\n                }\n            }\n            console.log(\"✅ Sorteos activos cargados: \".concat(raffles.length));\n            // Aplicar filtros que requieren los datos completos\n            if (filters === null || filters === void 0 ? void 0 : filters.category) {\n                raffles = raffles.filter((r)=>{\n                    var _r_product;\n                    return ((_r_product = r.product) === null || _r_product === void 0 ? void 0 : _r_product.category) === filters.category;\n                });\n            }\n            if ((filters === null || filters === void 0 ? void 0 : filters.minValue) !== undefined) {\n                raffles = raffles.filter((r)=>r.productValue >= filters.minValue);\n            }\n            if ((filters === null || filters === void 0 ? void 0 : filters.maxValue) !== undefined) {\n                raffles = raffles.filter((r)=>r.productValue <= filters.maxValue);\n            }\n            if (filters === null || filters === void 0 ? void 0 : filters.search) {\n                const searchLower = filters.search.toLowerCase();\n                raffles = raffles.filter((r)=>{\n                    var _r_product, _r_product1, _r_shop;\n                    return ((_r_product = r.product) === null || _r_product === void 0 ? void 0 : _r_product.name.toLowerCase().includes(searchLower)) || ((_r_product1 = r.product) === null || _r_product1 === void 0 ? void 0 : _r_product1.description.toLowerCase().includes(searchLower)) || ((_r_shop = r.shop) === null || _r_shop === void 0 ? void 0 : _r_shop.name.toLowerCase().includes(searchLower));\n                });\n            }\n            // Ordenar en memoria si hay filtro de shopId o si no se pudo ordenar en la consulta\n            if ((filters === null || filters === void 0 ? void 0 : filters.shopId) || (filters === null || filters === void 0 ? void 0 : filters.sortBy)) {\n                if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"newest\") {\n                    raffles.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n                } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"closest\") {\n                    raffles.sort((a, b)=>b.soldTickets - a.soldTickets);\n                } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"price-asc\") {\n                    raffles.sort((a, b)=>a.productValue - b.productValue);\n                } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"price-desc\") {\n                    raffles.sort((a, b)=>b.productValue - a.productValue);\n                }\n            }\n            // Aplicar paginación manual\n            const total = raffles.length;\n            const totalPages = Math.ceil(total / pageSize);\n            const paginatedRaffles = raffles.slice(offset, offset + pageSize);\n            return {\n                data: paginatedRaffles,\n                total,\n                page,\n                limit: pageSize,\n                totalPages\n            };\n        } catch (error) {\n            console.error(\"Error fetching active raffles:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Obtiene un sorteo específico por ID (público)\n   */ async getRaffleById (id) {\n        try {\n            const raffleDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"raffles\", id));\n            if (!raffleDoc.exists()) {\n                throw new Error(\"Raffle not found\");\n            }\n            return await convertRaffleDoc(raffleDoc);\n        } catch (error) {\n            console.error(\"Error fetching raffle:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Obtiene sorteos de una tienda específica (público)\n   */ async getRafflesByShop (shopId, filters) {\n        try {\n            const rafflesRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"raffles\");\n            // No ordenamos en la consulta para evitar problemas de índices compuestos\n            // Ordenaremos en memoria después\n            let q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(rafflesRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"shopId\", \"==\", shopId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.ACTIVE));\n            const allDocs = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            let raffles = [];\n            for (const docSnap of allDocs.docs){\n                const raffle = await convertRaffleDoc(docSnap);\n                raffles.push(raffle);\n            }\n            // Aplicar búsqueda si existe\n            if (filters === null || filters === void 0 ? void 0 : filters.search) {\n                const searchLower = filters.search.toLowerCase();\n                raffles = raffles.filter((r)=>{\n                    var _r_product, _r_product1;\n                    return ((_r_product = r.product) === null || _r_product === void 0 ? void 0 : _r_product.name.toLowerCase().includes(searchLower)) || ((_r_product1 = r.product) === null || _r_product1 === void 0 ? void 0 : _r_product1.description.toLowerCase().includes(searchLower));\n                });\n            }\n            // Ordenar en memoria\n            if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"newest\") {\n                raffles.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n            } else if ((filters === null || filters === void 0 ? void 0 : filters.sortBy) === \"closest\") {\n                raffles.sort((a, b)=>b.soldTickets - a.soldTickets);\n            } else {\n                raffles.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n            }\n            // Paginación\n            const pageSize1 = (filters === null || filters === void 0 ? void 0 : filters.limit) || 12;\n            const page1 = (filters === null || filters === void 0 ? void 0 : filters.page) || 1;\n            const offset1 = (page1 - 1) * pageSize1;\n            const total = raffles.length;\n            const totalPages = Math.ceil(total / pageSize1);\n            const paginatedRaffles = raffles.slice(offset1, offset1 + pageSize1);\n            return {\n                data: paginatedRaffles,\n                total,\n                page: page1,\n                limit: pageSize1,\n                totalPages\n            };\n        } catch (error) {\n            console.error(\"Error fetching shop raffles:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Obtiene categorías disponibles para filtrar\n   */ async getCategories () {\n        try {\n            const productsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"products\");\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(productsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", \"active\"));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const categories = new Set();\n            snapshot.docs.forEach((doc)=>{\n                const data = doc.data();\n                if (data.category) {\n                    categories.add(data.category);\n                }\n            });\n            return Array.from(categories).sort();\n        } catch (error) {\n            console.error(\"Error fetching categories:\", error);\n            return [];\n        }\n    },\n    /**\n   * Obtiene tiendas con sorteos activos\n   */ async getShopsWithActiveRaffles () {\n        try {\n            const rafflesRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"raffles\");\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(rafflesRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"status\", \"==\", _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.ACTIVE));\n            const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const shopIds = new Set();\n            snapshot.docs.forEach((doc)=>{\n                const data = doc.data();\n                if (data.shopId) {\n                    shopIds.add(data.shopId);\n                }\n            });\n            // Obtener información de las tiendas\n            const shops = [];\n            for (const shopId of shopIds){\n                try {\n                    const shopDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"shops\", shopId));\n                    if (shopDoc.exists()) {\n                        const shopData = shopDoc.data();\n                        shops.push({\n                            id: shopDoc.id,\n                            name: shopData.name || \"Tienda sin nombre\"\n                        });\n                    }\n                } catch (error) {\n                    console.error(\"Error loading shop \".concat(shopId, \":\"), error);\n                }\n            }\n            return shops.sort((a, b)=>a.name.localeCompare(b.name));\n        } catch (error) {\n            console.error(\"Error fetching shops:\", error);\n            return [];\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9maXJlYmFzZS1yYWZmbGUtc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBVTRCO0FBQ1E7QUFDa0I7QUF3QnRELG1EQUFtRDtBQUNuRCxNQUFNUyxtQkFBbUIsQ0FBQ0M7SUFDeEIsSUFBSUEsc0JBQUFBLGdDQUFBQSxVQUFXQyxNQUFNLEVBQUU7UUFDckIsT0FBT0QsVUFBVUMsTUFBTTtJQUN6QjtJQUNBLElBQUlELHFCQUFxQkUsTUFBTTtRQUM3QixPQUFPRjtJQUNUO0lBQ0EsSUFBSSxPQUFPQSxjQUFjLFVBQVU7UUFDakMsT0FBTyxJQUFJRSxLQUFLRjtJQUNsQjtJQUNBLE9BQU8sSUFBSUU7QUFDYjtBQUVBLHdEQUF3RDtBQUN4RCxNQUFNQyxtQkFBbUIsT0FBT0M7SUFDOUIsTUFBTUMsT0FBT0QsUUFBUUMsSUFBSTtJQUN6QixNQUFNQyxTQUFpQjtRQUNyQkMsSUFBSUgsUUFBUUcsRUFBRTtRQUNkQyxRQUFRSCxLQUFLRyxNQUFNLElBQUk7UUFDdkJDLFdBQVdKLEtBQUtJLFNBQVMsSUFBSTtRQUM3QkMsY0FBY0wsS0FBS0ssWUFBWSxJQUFJO1FBQ25DQyxjQUFjTixLQUFLTSxZQUFZLElBQUk7UUFDbkNDLGFBQWFQLEtBQUtPLFdBQVcsSUFBSTtRQUNqQ0MsUUFBUVIsS0FBS1EsTUFBTSxJQUFJZix1REFBWUEsQ0FBQ2dCLEtBQUs7UUFDekNDLGlCQUFpQlYsS0FBS1UsZUFBZSxJQUFJO1FBQ3pDQyxnQkFBZ0JYLEtBQUtXLGNBQWM7UUFDbkNDLG1CQUFtQlosS0FBS1ksaUJBQWlCO1FBQ3pDQyxXQUFXbkIsaUJBQWlCTSxLQUFLYSxTQUFTO1FBQzFDQyxXQUFXcEIsaUJBQWlCTSxLQUFLYyxTQUFTO1FBQzFDQyxhQUFhZixLQUFLZSxXQUFXLEdBQUdyQixpQkFBaUJNLEtBQUtlLFdBQVcsSUFBSUM7UUFDckVDLGtCQUFrQmpCLEtBQUtpQixnQkFBZ0IsR0FBR3ZCLGlCQUFpQk0s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LElBQUllLFFBQVFDLE1BQU0sSUFBSTt3QkFDcEIsTUFBTUMsV0FBV0YsUUFBUWxCLElBQUk7d0JBQzdCK0YsTUFBTXJDLElBQUksQ0FBQzs0QkFDVHhELElBQUlnQixRQUFRaEIsRUFBRTs0QkFDZHFCLE1BQU1ILFNBQVNHLElBQUksSUFBSTt3QkFDekI7b0JBQ0Y7Z0JBQ0YsRUFBRSxPQUFPTSxPQUFPO29CQUNkQyxRQUFRRCxLQUFLLENBQUMsc0JBQTZCLE9BQVAxQixRQUFPLE1BQUkwQjtnQkFDakQ7WUFDRjtZQUVBLE9BQU9rRSxNQUFNN0IsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUU1QyxJQUFJLENBQUN5RSxhQUFhLENBQUM1QixFQUFFN0MsSUFBSTtRQUN6RCxFQUFFLE9BQU9NLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkMsT0FBTyxFQUFFO1FBQ1g7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL2ZpcmViYXNlLXJhZmZsZS1zZXJ2aWNlLnRzP2RhZGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgY29sbGVjdGlvbixcbiAgcXVlcnksXG4gIHdoZXJlLFxuICBnZXREb2NzLFxuICBnZXREb2MsXG4gIGRvYyxcbiAgb3JkZXJCeSxcbiAgUXVlcnlEb2N1bWVudFNuYXBzaG90LFxuICBEb2N1bWVudERhdGEsXG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJ0AvbGliL2ZpcmViYXNlJztcbmltcG9ydCB7IFJhZmZsZSwgUmFmZmxlU3RhdHVzIH0gZnJvbSAnQC90eXBlcy9yYWZmbGUnO1xuaW1wb3J0IHsgUHJvZHVjdCB9IGZyb20gJ0AvdHlwZXMvcHJvZHVjdCc7XG5pbXBvcnQgeyBTaG9wIH0gZnJvbSAnQC90eXBlcy9zaG9wJztcblxuZXhwb3J0IGludGVyZmFjZSBSYWZmbGVGaWx0ZXJzIHtcbiAgY2F0ZWdvcnk/OiBzdHJpbmc7XG4gIHNob3BJZD86IHN0cmluZztcbiAgc3RhdHVzPzogc3RyaW5nO1xuICBtaW5WYWx1ZT86IG51bWJlcjtcbiAgbWF4VmFsdWU/OiBudW1iZXI7XG4gIHNlYXJjaD86IHN0cmluZztcbiAgc29ydEJ5PzogJ25ld2VzdCcgfCAnY2xvc2VzdCcgfCAncHJpY2UtYXNjJyB8ICdwcmljZS1kZXNjJztcbiAgcGFnZT86IG51bWJlcjtcbiAgbGltaXQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnaW5hdGVkUmFmZmxlcyB7XG4gIGRhdGE6IFJhZmZsZVtdO1xuICB0b3RhbDogbnVtYmVyO1xuICBwYWdlOiBudW1iZXI7XG4gIGxpbWl0OiBudW1iZXI7XG4gIHRvdGFsUGFnZXM6IG51bWJlcjtcbn1cblxuLy8gSGVscGVyIHBhcmEgY29udmVydGlyIEZpcmVzdG9yZSB0aW1lc3RhbXAgYSBEYXRlXG5jb25zdCBjb252ZXJ0VGltZXN0YW1wID0gKHRpbWVzdGFtcDogYW55KTogRGF0ZSA9PiB7XG4gIGlmICh0aW1lc3RhbXA/LnRvRGF0ZSkge1xuICAgIHJldHVybiB0aW1lc3RhbXAudG9EYXRlKCk7XG4gIH1cbiAgaWYgKHRpbWVzdGFtcCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gdGltZXN0YW1wO1xuICB9XG4gIGlmICh0eXBlb2YgdGltZXN0YW1wID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXApO1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZSgpO1xufTtcblxuLy8gSGVscGVyIHBhcmEgY29udmVydGlyIGRvY3VtZW50byBkZSBGaXJlc3RvcmUgYSBSYWZmbGVcbmNvbnN0IGNvbnZlcnRSYWZmbGVEb2MgPSBhc3luYyAoZG9jU25hcDogUXVlcnlEb2N1bWVudFNuYXBzaG90PERvY3VtZW50RGF0YT4pOiBQcm9taXNlPFJhZmZsZT4gPT4ge1xuICBjb25zdCBkYXRhID0gZG9jU25hcC5kYXRhKCk7XG4gIGNvbnN0IHJhZmZsZTogUmFmZmxlID0ge1xuICAgIGlkOiBkb2NTbmFwLmlkLFxuICAgIHNob3BJZDogZGF0YS5zaG9wSWQgfHwgJycsXG4gICAgcHJvZHVjdElkOiBkYXRhLnByb2R1Y3RJZCB8fCAnJyxcbiAgICBwcm9kdWN0VmFsdWU6IGRhdGEucHJvZHVjdFZhbHVlIHx8IDAsXG4gICAgdG90YWxUaWNrZXRzOiBkYXRhLnRvdGFsVGlja2V0cyB8fCAwLFxuICAgIHNvbGRUaWNrZXRzOiBkYXRhLnNvbGRUaWNrZXRzIHx8IDAsXG4gICAgc3RhdHVzOiBkYXRhLnN0YXR1cyB8fCBSYWZmbGVTdGF0dXMuRFJBRlQsXG4gICAgcmVxdWlyZXNEZXBvc2l0OiBkYXRhLnJlcXVpcmVzRGVwb3NpdCB8fCBmYWxzZSxcbiAgICB3aW5uZXJUaWNrZXRJZDogZGF0YS53aW5uZXJUaWNrZXRJZCxcbiAgICBzcGVjaWFsQ29uZGl0aW9uczogZGF0YS5zcGVjaWFsQ29uZGl0aW9ucyxcbiAgICBjcmVhdGVkQXQ6IGNvbnZlcnRUaW1lc3RhbXAoZGF0YS5jcmVhdGVkQXQpLFxuICAgIHVwZGF0ZWRBdDogY29udmVydFRpbWVzdGFtcChkYXRhLnVwZGF0ZWRBdCksXG4gICAgYWN0aXZhdGVkQXQ6IGRhdGEuYWN0aXZhdGVkQXQgPyBjb252ZXJ0VGltZXN0YW1wKGRhdGEuYWN0aXZhdGVkQXQpIDogdW5kZWZpbmVkLFxuICAgIHJhZmZsZUV4ZWN1dGVkQXQ6IGRhdGEucmFmZmxlRXhlY3V0ZWRBdCA/IGNvbnZlcnRUaW1lc3RhbXAoZGF0YS5yYWZmbGVFeGVjdXRlZEF0KSA6IHVuZGVmaW5lZCxcbiAgfTtcblxuICAvLyBDYXJnYXIgcmVsYWNpb25lcyBzaSBleGlzdGVuXG4gIGlmIChkYXRhLnNob3BJZCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzaG9wRG9jID0gYXdhaXQgZ2V0RG9jKGRvYyhkYiwgJ3Nob3BzJywgZGF0YS5zaG9wSWQpKTtcbiAgICAgIGlmIChzaG9wRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIGNvbnN0IHNob3BEYXRhID0gc2hvcERvYy5kYXRhKCk7XG4gICAgICAgIHJhZmZsZS5zaG9wID0ge1xuICAgICAgICAgIGlkOiBzaG9wRG9jLmlkLFxuICAgICAgICAgIHVzZXJJZDogc2hvcERhdGEudXNlcklkIHx8ICcnLFxuICAgICAgICAgIG5hbWU6IHNob3BEYXRhLm5hbWUgfHwgJycsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHNob3BEYXRhLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIGxvZ286IHNob3BEYXRhLmxvZ28sXG4gICAgICAgICAgcHVibGljRW1haWw6IHNob3BEYXRhLnB1YmxpY0VtYWlsLFxuICAgICAgICAgIHBob25lOiBzaG9wRGF0YS5waG9uZSxcbiAgICAgICAgICBzb2NpYWxNZWRpYTogc2hvcERhdGEuc29jaWFsTWVkaWEsXG4gICAgICAgICAgc3RhdHVzOiBzaG9wRGF0YS5zdGF0dXMgfHwgJ3BlbmRpbmcnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogY29udmVydFRpbWVzdGFtcChzaG9wRGF0YS5jcmVhdGVkQXQpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogY29udmVydFRpbWVzdGFtcChzaG9wRGF0YS51cGRhdGVkQXQpLFxuICAgICAgICB9IGFzIFNob3A7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2hvcDonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRhdGEucHJvZHVjdElkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb2R1Y3REb2MgPSBhd2FpdCBnZXREb2MoZG9jKGRiLCAncHJvZHVjdHMnLCBkYXRhLnByb2R1Y3RJZCkpO1xuICAgICAgaWYgKHByb2R1Y3REb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgY29uc3QgcHJvZHVjdERhdGEgPSBwcm9kdWN0RG9jLmRhdGEoKTtcbiAgICAgICAgcmFmZmxlLnByb2R1Y3QgPSB7XG4gICAgICAgICAgaWQ6IHByb2R1Y3REb2MuaWQsXG4gICAgICAgICAgc2hvcElkOiBwcm9kdWN0RGF0YS5zaG9wSWQgfHwgJycsXG4gICAgICAgICAgbmFtZTogcHJvZHVjdERhdGEubmFtZSB8fCAnJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogcHJvZHVjdERhdGEuZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgICAgdmFsdWU6IHByb2R1Y3REYXRhLnZhbHVlIHx8IDAsXG4gICAgICAgICAgaGVpZ2h0OiBwcm9kdWN0RGF0YS5oZWlnaHQgfHwgMCxcbiAgICAgICAgICB3aWR0aDogcHJvZHVjdERhdGEud2lkdGggfHwgMCxcbiAgICAgICAgICBkZXB0aDogcHJvZHVjdERhdGEuZGVwdGggfHwgMCxcbiAgICAgICAgICByZXF1aXJlc0RlcG9zaXQ6IHByb2R1Y3REYXRhLnJlcXVpcmVzRGVwb3NpdCB8fCBmYWxzZSxcbiAgICAgICAgICBjYXRlZ29yeTogcHJvZHVjdERhdGEuY2F0ZWdvcnksXG4gICAgICAgICAgbWFpbkltYWdlOiBwcm9kdWN0RGF0YS5tYWluSW1hZ2UsXG4gICAgICAgICAgc3RhdHVzOiBwcm9kdWN0RGF0YS5zdGF0dXMgfHwgJ2luYWN0aXZlJyxcbiAgICAgICAgICBjcmVhdGVkQXQ6IGNvbnZlcnRUaW1lc3RhbXAocHJvZHVjdERhdGEuY3JlYXRlZEF0KSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IGNvbnZlcnRUaW1lc3RhbXAocHJvZHVjdERhdGEudXBkYXRlZEF0KSxcbiAgICAgICAgfSBhcyBQcm9kdWN0O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHByb2R1Y3Q6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByYWZmbGU7XG59O1xuXG5leHBvcnQgY29uc3QgZmlyZWJhc2VSYWZmbGVTZXJ2aWNlID0ge1xuICAvKipcbiAgICogT2J0aWVuZSBzb3J0ZW9zIGFjdGl2b3MgY29uIGZpbHRyb3MgeSBiw7pzcXVlZGFcbiAgICovXG4gIGFzeW5jIGdldEFjdGl2ZVJhZmZsZXMoZmlsdGVycz86IFJhZmZsZUZpbHRlcnMpOiBQcm9taXNlPFBhZ2luYXRlZFJhZmZsZXM+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmFmZmxlc1JlZiA9IGNvbGxlY3Rpb24oZGIsICdyYWZmbGVzJyk7XG4gICAgICBcbiAgICAgIC8vIEludGVudGFyIGNvbnN1bHRhIGNvbiBmaWx0cm8gZGUgc3RhdHVzLCBwZXJvIHNpIGZhbGxhIHBvciDDrW5kaWNlLCBvYnRlbmVyIHRvZG9zIHkgZmlsdHJhclxuICAgICAgbGV0IGFsbERvY3M7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgcSA9IHF1ZXJ5KHJhZmZsZXNSZWYsIHdoZXJlKCdzdGF0dXMnLCAnPT0nLCBSYWZmbGVTdGF0dXMuQUNUSVZFKSk7XG5cbiAgICAgICAgLy8gQXBsaWNhciBmaWx0cm9zIGFkaWNpb25hbGVzXG4gICAgICAgIGlmIChmaWx0ZXJzPy5zaG9wSWQpIHtcbiAgICAgICAgICBxID0gcXVlcnkocSwgd2hlcmUoJ3Nob3BJZCcsICc9PScsIGZpbHRlcnMuc2hvcElkKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlbnRhciBvcmRlbmFyIHNpIG5vIGhheSBmaWx0cm8gZGUgc2hvcElkIChwYXJhIGV2aXRhciBwcm9ibGVtYXMgZGUgw61uZGljZXMgY29tcHVlc3RvcylcbiAgICAgICAgaWYgKCFmaWx0ZXJzPy5zaG9wSWQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGZpbHRlcnM/LnNvcnRCeSA9PT0gJ25ld2VzdCcpIHtcbiAgICAgICAgICAgICAgcSA9IHF1ZXJ5KHEsIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXJzPy5zb3J0QnkgPT09ICdjbG9zZXN0Jykge1xuICAgICAgICAgICAgICBxID0gcXVlcnkocSwgb3JkZXJCeSgnc29sZFRpY2tldHMnLCAnZGVzYycpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsdGVycz8uc29ydEJ5ID09PSAncHJpY2UtYXNjJykge1xuICAgICAgICAgICAgICBxID0gcXVlcnkocSwgb3JkZXJCeSgncHJvZHVjdFZhbHVlJywgJ2FzYycpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsdGVycz8uc29ydEJ5ID09PSAncHJpY2UtZGVzYycpIHtcbiAgICAgICAgICAgICAgcSA9IHF1ZXJ5KHEsIG9yZGVyQnkoJ3Byb2R1Y3RWYWx1ZScsICdkZXNjJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcSA9IHF1ZXJ5KHEsIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsRG9jcyA9IGF3YWl0IGdldERvY3MocSk7XG4gICAgICAgICAgfSBjYXRjaCAob3JkZXJFcnJvcjogYW55KSB7XG4gICAgICAgICAgICAvLyBTaSBmYWxsYSBlbCBvcmRlckJ5LCBpbnRlbnRhciBzaW4gb3JkZW5hclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciBjb24gb3JkZXJCeSwgb2J0ZW5pZW5kbyBzaW4gb3JkZW5hcjonLCBvcmRlckVycm9yKTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJzPy5zaG9wSWQpIHtcbiAgICAgICAgICAgICAgcSA9IHF1ZXJ5KHJhZmZsZXNSZWYsIHdoZXJlKCdzdGF0dXMnLCAnPT0nLCBSYWZmbGVTdGF0dXMuQUNUSVZFKSwgd2hlcmUoJ3Nob3BJZCcsICc9PScsIGZpbHRlcnMuc2hvcElkKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBxID0gcXVlcnkocmFmZmxlc1JlZiwgd2hlcmUoJ3N0YXR1cycsICc9PScsIFJhZmZsZVN0YXR1cy5BQ1RJVkUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsbERvY3MgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGxEb2NzID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAocXVlcnlFcnJvcjogYW55KSB7XG4gICAgICAgIC8vIFNpIGZhbGxhIGxhIGNvbnN1bHRhIGNvbiB3aGVyZSwgb2J0ZW5lciB0b2RvcyB5IGZpbHRyYXIgZW4gbWVtb3JpYVxuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGVuIGNvbnN1bHRhIGNvbiB3aGVyZSwgb2J0ZW5pZW5kbyB0b2RvcyBsb3Mgc29ydGVvczonLCBxdWVyeUVycm9yKTtcbiAgICAgICAgY29uc3QgYWxsUmFmZmxlc1F1ZXJ5ID0gcXVlcnkocmFmZmxlc1JlZik7XG4gICAgICAgIGNvbnN0IGFsbFJhZmZsZXNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoYWxsUmFmZmxlc1F1ZXJ5KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZpbHRyYXIgcG9yIHN0YXR1cyBhY3Rpdm8gZW4gbWVtb3JpYVxuICAgICAgICBhbGxEb2NzID0ge1xuICAgICAgICAgIGRvY3M6IGFsbFJhZmZsZXNTbmFwc2hvdC5kb2NzLmZpbHRlcihkb2MgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZG9jLmRhdGEoKS5zdGF0dXM7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzID09PSBSYWZmbGVTdGF0dXMuQUNUSVZFIHx8IHN0YXR1cyA9PT0gJ2FjdGl2ZSc7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSBhcyBhbnk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBTb3J0ZW9zIGFjdGl2b3MgZW5jb250cmFkb3MgZGVzcHXDqXMgZGUgZmlsdHJhcjogJHthbGxEb2NzLmRvY3MubGVuZ3RofSBkZSAke2FsbFJhZmZsZXNTbmFwc2hvdC5kb2NzLmxlbmd0aH0gdG90YWxlc2ApO1xuICAgICAgfVxuXG4gICAgICBsZXQgcmFmZmxlczogUmFmZmxlW10gPSBbXTtcblxuICAgICAgLy8gQ29udmVydGlyIGRvY3VtZW50b3NcbiAgICAgIGZvciAoY29uc3QgZG9jU25hcCBvZiBhbGxEb2NzLmRvY3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByYWZmbGUgPSBhd2FpdCBjb252ZXJ0UmFmZmxlRG9jKGRvY1NuYXApO1xuICAgICAgICAgIHJhZmZsZXMucHVzaChyYWZmbGUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbnZlcnRpbmcgcmFmZmxlIGRvYzonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYOKchSBTb3J0ZW9zIGFjdGl2b3MgY2FyZ2Fkb3M6ICR7cmFmZmxlcy5sZW5ndGh9YCk7XG5cbiAgICAgIC8vIEFwbGljYXIgZmlsdHJvcyBxdWUgcmVxdWllcmVuIGxvcyBkYXRvcyBjb21wbGV0b3NcbiAgICAgIGlmIChmaWx0ZXJzPy5jYXRlZ29yeSkge1xuICAgICAgICByYWZmbGVzID0gcmFmZmxlcy5maWx0ZXIoKHIpID0+IHIucHJvZHVjdD8uY2F0ZWdvcnkgPT09IGZpbHRlcnMuY2F0ZWdvcnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlsdGVycz8ubWluVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByYWZmbGVzID0gcmFmZmxlcy5maWx0ZXIoKHIpID0+IHIucHJvZHVjdFZhbHVlID49IGZpbHRlcnMubWluVmFsdWUhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbHRlcnM/Lm1heFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmFmZmxlcyA9IHJhZmZsZXMuZmlsdGVyKChyKSA9PiByLnByb2R1Y3RWYWx1ZSA8PSBmaWx0ZXJzLm1heFZhbHVlISk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXJzPy5zZWFyY2gpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoTG93ZXIgPSBmaWx0ZXJzLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByYWZmbGVzID0gcmFmZmxlcy5maWx0ZXIoXG4gICAgICAgICAgKHIpID0+XG4gICAgICAgICAgICByLnByb2R1Y3Q/Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcikgfHxcbiAgICAgICAgICAgIHIucHJvZHVjdD8uZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcikgfHxcbiAgICAgICAgICAgIHIuc2hvcD8ubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaExvd2VyKSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gT3JkZW5hciBlbiBtZW1vcmlhIHNpIGhheSBmaWx0cm8gZGUgc2hvcElkIG8gc2kgbm8gc2UgcHVkbyBvcmRlbmFyIGVuIGxhIGNvbnN1bHRhXG4gICAgICBpZiAoZmlsdGVycz8uc2hvcElkIHx8IGZpbHRlcnM/LnNvcnRCeSkge1xuICAgICAgICBpZiAoZmlsdGVycz8uc29ydEJ5ID09PSAnbmV3ZXN0Jykge1xuICAgICAgICAgIHJhZmZsZXMuc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkQXQuZ2V0VGltZSgpIC0gYS5jcmVhdGVkQXQuZ2V0VGltZSgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXJzPy5zb3J0QnkgPT09ICdjbG9zZXN0Jykge1xuICAgICAgICAgIHJhZmZsZXMuc29ydCgoYSwgYikgPT4gYi5zb2xkVGlja2V0cyAtIGEuc29sZFRpY2tldHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbHRlcnM/LnNvcnRCeSA9PT0gJ3ByaWNlLWFzYycpIHtcbiAgICAgICAgICByYWZmbGVzLnNvcnQoKGEsIGIpID0+IGEucHJvZHVjdFZhbHVlIC0gYi5wcm9kdWN0VmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbHRlcnM/LnNvcnRCeSA9PT0gJ3ByaWNlLWRlc2MnKSB7XG4gICAgICAgICAgcmFmZmxlcy5zb3J0KChhLCBiKSA9PiBiLnByb2R1Y3RWYWx1ZSAtIGEucHJvZHVjdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBcGxpY2FyIHBhZ2luYWNpw7NuIG1hbnVhbFxuICAgICAgY29uc3QgdG90YWwgPSByYWZmbGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHRvdGFsUGFnZXMgPSBNYXRoLmNlaWwodG90YWwgLyBwYWdlU2l6ZSk7XG4gICAgICBjb25zdCBwYWdpbmF0ZWRSYWZmbGVzID0gcmFmZmxlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHBhZ2VTaXplKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGFnaW5hdGVkUmFmZmxlcyxcbiAgICAgICAgdG90YWwsXG4gICAgICAgIHBhZ2UsXG4gICAgICAgIGxpbWl0OiBwYWdlU2l6ZSxcbiAgICAgICAgdG90YWxQYWdlcyxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGFjdGl2ZSByYWZmbGVzOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogT2J0aWVuZSB1biBzb3J0ZW8gZXNwZWPDrWZpY28gcG9yIElEIChww7pibGljbylcbiAgICovXG4gIGFzeW5jIGdldFJhZmZsZUJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8UmFmZmxlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhZmZsZURvYyA9IGF3YWl0IGdldERvYyhkb2MoZGIsICdyYWZmbGVzJywgaWQpKTtcbiAgICAgIGlmICghcmFmZmxlRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmFmZmxlIG5vdCBmb3VuZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IGNvbnZlcnRSYWZmbGVEb2MocmFmZmxlRG9jIGFzIFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdDxEb2N1bWVudERhdGE+KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmFmZmxlOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogT2J0aWVuZSBzb3J0ZW9zIGRlIHVuYSB0aWVuZGEgZXNwZWPDrWZpY2EgKHDDumJsaWNvKVxuICAgKi9cbiAgYXN5bmMgZ2V0UmFmZmxlc0J5U2hvcChzaG9wSWQ6IHN0cmluZywgZmlsdGVycz86IE9taXQ8UmFmZmxlRmlsdGVycywgJ3Nob3BJZCc+KTogUHJvbWlzZTxQYWdpbmF0ZWRSYWZmbGVzPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhZmZsZXNSZWYgPSBjb2xsZWN0aW9uKGRiLCAncmFmZmxlcycpO1xuICAgICAgLy8gTm8gb3JkZW5hbW9zIGVuIGxhIGNvbnN1bHRhIHBhcmEgZXZpdGFyIHByb2JsZW1hcyBkZSDDrW5kaWNlcyBjb21wdWVzdG9zXG4gICAgICAvLyBPcmRlbmFyZW1vcyBlbiBtZW1vcmlhIGRlc3B1w6lzXG4gICAgICBsZXQgcSA9IHF1ZXJ5KHJhZmZsZXNSZWYsIHdoZXJlKCdzaG9wSWQnLCAnPT0nLCBzaG9wSWQpLCB3aGVyZSgnc3RhdHVzJywgJz09JywgUmFmZmxlU3RhdHVzLkFDVElWRSkpO1xuXG4gICAgICBjb25zdCBhbGxEb2NzID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICAgIGxldCByYWZmbGVzOiBSYWZmbGVbXSA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IGRvY1NuYXAgb2YgYWxsRG9jcy5kb2NzKSB7XG4gICAgICAgIGNvbnN0IHJhZmZsZSA9IGF3YWl0IGNvbnZlcnRSYWZmbGVEb2MoZG9jU25hcCk7XG4gICAgICAgIHJhZmZsZXMucHVzaChyYWZmbGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBcGxpY2FyIGLDunNxdWVkYSBzaSBleGlzdGVcbiAgICAgIGlmIChmaWx0ZXJzPy5zZWFyY2gpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoTG93ZXIgPSBmaWx0ZXJzLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByYWZmbGVzID0gcmFmZmxlcy5maWx0ZXIoXG4gICAgICAgICAgKHIpID0+XG4gICAgICAgICAgICByLnByb2R1Y3Q/Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcikgfHxcbiAgICAgICAgICAgIHIucHJvZHVjdD8uZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlciksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIE9yZGVuYXIgZW4gbWVtb3JpYVxuICAgICAgaWYgKGZpbHRlcnM/LnNvcnRCeSA9PT0gJ25ld2VzdCcpIHtcbiAgICAgICAgcmFmZmxlcy5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRBdC5nZXRUaW1lKCkgLSBhLmNyZWF0ZWRBdC5nZXRUaW1lKCkpO1xuICAgICAgfSBlbHNlIGlmIChmaWx0ZXJzPy5zb3J0QnkgPT09ICdjbG9zZXN0Jykge1xuICAgICAgICByYWZmbGVzLnNvcnQoKGEsIGIpID0+IGIuc29sZFRpY2tldHMgLSBhLnNvbGRUaWNrZXRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhZmZsZXMuc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkQXQuZ2V0VGltZSgpIC0gYS5jcmVhdGVkQXQuZ2V0VGltZSgpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUGFnaW5hY2nDs25cbiAgICAgIGNvbnN0IHBhZ2VTaXplID0gZmlsdGVycz8ubGltaXQgfHwgMTI7XG4gICAgICBjb25zdCBwYWdlID0gZmlsdGVycz8ucGFnZSB8fCAxO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKHBhZ2UgLSAxKSAqIHBhZ2VTaXplO1xuICAgICAgY29uc3QgdG90YWwgPSByYWZmbGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHRvdGFsUGFnZXMgPSBNYXRoLmNlaWwodG90YWwgLyBwYWdlU2l6ZSk7XG4gICAgICBjb25zdCBwYWdpbmF0ZWRSYWZmbGVzID0gcmFmZmxlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHBhZ2VTaXplKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGFnaW5hdGVkUmFmZmxlcyxcbiAgICAgICAgdG90YWwsXG4gICAgICAgIHBhZ2UsXG4gICAgICAgIGxpbWl0OiBwYWdlU2l6ZSxcbiAgICAgICAgdG90YWxQYWdlcyxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNob3AgcmFmZmxlczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9idGllbmUgY2F0ZWdvcsOtYXMgZGlzcG9uaWJsZXMgcGFyYSBmaWx0cmFyXG4gICAqL1xuICBhc3luYyBnZXRDYXRlZ29yaWVzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvZHVjdHNSZWYgPSBjb2xsZWN0aW9uKGRiLCAncHJvZHVjdHMnKTtcbiAgICAgIGNvbnN0IHEgPSBxdWVyeShwcm9kdWN0c1JlZiwgd2hlcmUoJ3N0YXR1cycsICc9PScsICdhY3RpdmUnKSk7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG5cbiAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgIHNuYXBzaG90LmRvY3MuZm9yRWFjaCgoZG9jKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xuICAgICAgICBpZiAoZGF0YS5jYXRlZ29yeSkge1xuICAgICAgICAgIGNhdGVnb3JpZXMuYWRkKGRhdGEuY2F0ZWdvcnkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2F0ZWdvcmllcykuc29ydCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjYXRlZ29yaWVzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9idGllbmUgdGllbmRhcyBjb24gc29ydGVvcyBhY3Rpdm9zXG4gICAqL1xuICBhc3luYyBnZXRTaG9wc1dpdGhBY3RpdmVSYWZmbGVzKCk6IFByb21pc2U8QXJyYXk8eyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfT4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmFmZmxlc1JlZiA9IGNvbGxlY3Rpb24oZGIsICdyYWZmbGVzJyk7XG4gICAgICBjb25zdCBxID0gcXVlcnkocmFmZmxlc1JlZiwgd2hlcmUoJ3N0YXR1cycsICc9PScsIFJhZmZsZVN0YXR1cy5BQ1RJVkUpKTtcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcblxuICAgICAgY29uc3Qgc2hvcElkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgc25hcHNob3QuZG9jcy5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XG4gICAgICAgIGlmIChkYXRhLnNob3BJZCkge1xuICAgICAgICAgIHNob3BJZHMuYWRkKGRhdGEuc2hvcElkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIE9idGVuZXIgaW5mb3JtYWNpw7NuIGRlIGxhcyB0aWVuZGFzXG4gICAgICBjb25zdCBzaG9wczogQXJyYXk8eyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfT4gPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc2hvcElkIG9mIHNob3BJZHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzaG9wRG9jID0gYXdhaXQgZ2V0RG9jKGRvYyhkYiwgJ3Nob3BzJywgc2hvcElkKSk7XG4gICAgICAgICAgaWYgKHNob3BEb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNob3BEYXRhID0gc2hvcERvYy5kYXRhKCk7XG4gICAgICAgICAgICBzaG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IHNob3BEb2MuaWQsXG4gICAgICAgICAgICAgIG5hbWU6IHNob3BEYXRhLm5hbWUgfHwgJ1RpZW5kYSBzaW4gbm9tYnJlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nIHNob3AgJHtzaG9wSWR9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvcHMuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNob3BzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0sXG59O1xuXG4iXSwibmFtZXMiOlsiY29sbGVjdGlvbiIsInF1ZXJ5Iiwid2hlcmUiLCJnZXREb2NzIiwiZ2V0RG9jIiwiZG9jIiwib3JkZXJCeSIsImRiIiwiUmFmZmxlU3RhdHVzIiwiY29udmVydFRpbWVzdGFtcCIsInRpbWVzdGFtcCIsInRvRGF0ZSIsIkRhdGUiLCJjb252ZXJ0UmFmZmxlRG9jIiwiZG9jU25hcCIsImRhdGEiLCJyYWZmbGUiLCJpZCIsInNob3BJZCIsInByb2R1Y3RJZCIsInByb2R1Y3RWYWx1ZSIsInRvdGFsVGlja2V0cyIsInNvbGRUaWNrZXRzIiwic3RhdHVzIiwiRFJBRlQiLCJyZXF1aXJlc0RlcG9zaXQiLCJ3aW5uZXJUaWNrZXRJZCIsInNwZWNpYWxDb25kaXRpb25zIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwiYWN0aXZhdGVkQXQiLCJ1bmRlZmluZWQiLCJyYWZmbGVFeGVjdXRlZEF0Iiwic2hvcERvYyIsImV4aXN0cyIsInNob3BEYXRhIiwic2hvcCIsInVzZXJJZCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImxvZ28iLCJwdWJsaWNFbWFpbCIsInBob25lIiwic29jaWFsTWVkaWEiLCJlcnJvciIsImNvbnNvbGUiLCJwcm9kdWN0RG9jIiwicHJvZHVjdERhdGEiLCJwcm9kdWN0IiwidmFsdWUiLCJoZWlnaHQiLCJ3aWR0aCIsImRlcHRoIiwiY2F0ZWdvcnkiLCJtYWluSW1hZ2UiLCJmaXJlYmFzZVJhZmZsZVNlcnZpY2UiLCJnZXRBY3RpdmVSYWZmbGVzIiwiZmlsdGVycyIsInJhZmZsZXNSZWYiLCJhbGxEb2NzIiwicSIsIkFDVElWRSIsInNvcnRCeSIsIm9yZGVyRXJyb3IiLCJ3YXJuIiwicXVlcnlFcnJvciIsImFsbFJhZmZsZXNRdWVyeSIsImFsbFJhZmZsZXNTbmFwc2hvdCIsImRvY3MiLCJmaWx0ZXIiLCJsb2ciLCJsZW5ndGgiLCJyYWZmbGVzIiwicHVzaCIsInIiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwic2VhcmNoIiwic2VhcmNoTG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic29ydCIsImEiLCJiIiwiZ2V0VGltZSIsInRvdGFsIiwidG90YWxQYWdlcyIsIk1hdGgiLCJjZWlsIiwicGFnZVNpemUiLCJwYWdpbmF0ZWRSYWZmbGVzIiwic2xpY2UiLCJvZmZzZXQiLCJwYWdlIiwibGltaXQiLCJnZXRSYWZmbGVCeUlkIiwicmFmZmxlRG9jIiwiRXJyb3IiLCJnZXRSYWZmbGVzQnlTaG9wIiwiZ2V0Q2F0ZWdvcmllcyIsInByb2R1Y3RzUmVmIiwic25hcHNob3QiLCJjYXRlZ29yaWVzIiwiU2V0IiwiZm9yRWFjaCIsImFkZCIsIkFycmF5IiwiZnJvbSIsImdldFNob3BzV2l0aEFjdGl2ZVJhZmZsZXMiLCJzaG9wSWRzIiwic2hvcHMiLCJsb2NhbGVDb21wYXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/firebase-raffle-service.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/firebase-raffle-write-service.ts":
/*!*******************************************************!*\
  !*** ./src/services/firebase-raffle-write-service.ts ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   firebaseRaffleWriteService: function() { return /* binding */ firebaseRaffleWriteService; }\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/../node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* harmony import */ var _types_raffle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/types/raffle */ \"(app-pages-browser)/./src/types/raffle.ts\");\n\n\n\n// Helper para convertir Firestore timestamp a Date\nconst convertTimestamp = (timestamp)=>{\n    if (timestamp === null || timestamp === void 0 ? void 0 : timestamp.toDate) {\n        return timestamp.toDate();\n    }\n    if (timestamp instanceof Date) {\n        return timestamp;\n    }\n    if (typeof timestamp === \"string\") {\n        return new Date(timestamp);\n    }\n    return new Date();\n};\n// Helper para convertir documento de Firestore a Raffle\nconst convertRaffleDoc = async (docSnap)=>{\n    const data = docSnap.data();\n    return {\n        id: docSnap.id,\n        shopId: data.shopId || \"\",\n        productId: data.productId || \"\",\n        productValue: data.productValue || 0,\n        totalTickets: data.totalTickets || 0,\n        soldTickets: data.soldTickets || 0,\n        status: data.status || _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.DRAFT,\n        requiresDeposit: data.requiresDeposit || false,\n        winnerTicketId: data.winnerTicketId,\n        specialConditions: data.specialConditions,\n        createdAt: convertTimestamp(data.createdAt),\n        updatedAt: convertTimestamp(data.updatedAt),\n        activatedAt: data.activatedAt ? convertTimestamp(data.activatedAt) : undefined,\n        raffleExecutedAt: data.raffleExecutedAt ? convertTimestamp(data.raffleExecutedAt) : undefined\n    };\n};\nconst firebaseRaffleWriteService = {\n    /**\n   * Crea un nuevo sorteo\n   * Calcula automáticamente los tickets como el doble del valor del producto\n   */ async createRaffle (data) {\n        try {\n            // Obtener el producto para calcular los tickets\n            const productDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"products\", data.productId));\n            if (!productDoc.exists()) {\n                throw new Error(\"Producto no encontrado\");\n            }\n            const productData = productDoc.data();\n            const productValue = productData.value || 0;\n            // Calcular tickets: doble del valor del producto\n            const totalTickets = Math.floor(productValue * 2);\n            if (totalTickets <= 0) {\n                throw new Error(\"El valor del producto debe ser mayor a 0\");\n            }\n            const rafflesRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"raffles\");\n            const raffleData = {\n                shopId: data.shopId,\n                productId: data.productId,\n                productValue: productValue,\n                totalTickets: totalTickets,\n                soldTickets: 0,\n                status: _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.DRAFT,\n                requiresDeposit: productData.requiresDeposit || false,\n                specialConditions: data.specialConditions || null,\n                winnerTicketId: null,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            };\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)(rafflesRef, raffleData);\n            const raffleDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(docRef);\n            if (!raffleDoc.exists()) {\n                throw new Error(\"Error al crear el sorteo\");\n            }\n            return await convertRaffleDoc(raffleDoc);\n        } catch (error) {\n            console.error(\"Error creating raffle:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Actualiza un sorteo existente\n   */ async updateRaffle (id, data) {\n        try {\n            const raffleRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"raffles\", id);\n            const updateData = {\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            };\n            if (data.specialConditions !== undefined) {\n                updateData.specialConditions = data.specialConditions;\n            }\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(raffleRef, updateData);\n            const updatedDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(raffleRef);\n            if (!updatedDoc.exists()) {\n                throw new Error(\"Sorteo no encontrado\");\n            }\n            return await convertRaffleDoc(updatedDoc);\n        } catch (error) {\n            console.error(\"Error updating raffle:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Envía un sorteo para aprobación\n   */ async submitForApproval (id) {\n        try {\n            const raffleRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"raffles\", id);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(raffleRef, {\n                status: _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.PENDING_APPROVAL,\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            });\n            const updatedDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(raffleRef);\n            if (!updatedDoc.exists()) {\n                throw new Error(\"Sorteo no encontrado\");\n            }\n            return await convertRaffleDoc(updatedDoc);\n        } catch (error) {\n            console.error(\"Error submitting raffle for approval:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Cancela un sorteo\n   */ async cancelRaffle (id) {\n        try {\n            const raffleRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, \"raffles\", id);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(raffleRef, {\n                status: _types_raffle__WEBPACK_IMPORTED_MODULE_2__.RaffleStatus.CANCELLED,\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            });\n            const updatedDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(raffleRef);\n            if (!updatedDoc.exists()) {\n                throw new Error(\"Sorteo no encontrado\");\n            }\n            return await convertRaffleDoc(updatedDoc);\n        } catch (error) {\n            console.error(\"Error cancelling raffle:\", error);\n            throw error;\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9maXJlYmFzZS1yYWZmbGUtd3JpdGUtc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBUzRCO0FBQ1E7QUFDb0Q7QUFHeEYsbURBQW1EO0FBQ25ELE1BQU1RLG1CQUFtQixDQUFDQztJQUN4QixJQUFJQSxzQkFBQUEsZ0NBQUFBLFVBQVdDLE1BQU0sRUFBRTtRQUNyQixPQUFPRCxVQUFVQyxNQUFNO0lBQ3pCO0lBQ0EsSUFBSUQscUJBQXFCRSxNQUFNO1FBQzdCLE9BQU9GO0lBQ1Q7SUFDQSxJQUFJLE9BQU9BLGNBQWMsVUFBVTtRQUNqQyxPQUFPLElBQUlFLEtBQUtGO0lBQ2xCO0lBQ0EsT0FBTyxJQUFJRTtBQUNiO0FBRUEsd0RBQXdEO0FBQ3hELE1BQU1DLG1CQUFtQixPQUFPQztJQUM5QixNQUFNQyxPQUFPRCxRQUFRQyxJQUFJO0lBQ3pCLE9BQU87UUFDTEMsSUFBSUYsUUFBUUUsRUFBRTtRQUNkQyxRQUFRRixLQUFLRSxNQUFNLElBQUk7UUFDdkJDLFdBQVdILEtBQUtHLFNBQVMsSUFBSTtRQUM3QkMsY0FBY0osS0FBS0ksWUFBWSxJQUFJO1FBQ25DQyxjQUFjTCxLQUFLSyxZQUFZLElBQUk7UUFDbkNDLGFBQWFOLEtBQUtNLFdBQVcsSUFBSTtRQUNqQ0MsUUFBUVAsS0FBS08sTUFBTSxJQUFJZCx1REFBWUEsQ0FBQ2UsS0FBSztRQUN6Q0MsaUJBQWlCVCxLQUFLUyxlQUFlLElBQUk7UUFDekNDLGdCQUFnQlYsS0FBS1UsY0FBYztRQUNuQ0MsbUJBQW1CWCxLQUFLVyxpQkFBaUI7UUFDekNDLFdBQVdsQixpQkFBaUJNLEtBQUtZLFNBQVM7UUFDMUNDLFdBQVduQixpQkFBaUJNLEtBQUthLFNBQVM7UUFDMUNDLGFBQWFkLEtBQUtjLFdBQVcsR0FBR3BCLGlCQUFpQk0sS0FBS2MsV0FBVyxJQUFJQztRQUNyRUMsa0JBQWtCaEIsS0FBS2dCLGdCQUFnQixHQUFHdEIsaUJBQWlCTSxLQUFL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UUQsS0FBSyxDQUFDLHlDQUF5Q0E7WUFDdkQsTUFBTUE7UUFDUjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFNUSxjQUFhckMsRUFBVTtRQUMzQixJQUFJO1lBQ0YsTUFBTWdDLFlBQVk1Qyx1REFBR0EsQ0FBQ0csNkNBQUVBLEVBQUUsV0FBV1M7WUFDckMsTUFBTWIsNkRBQVNBLENBQUM2QyxXQUFXO2dCQUN6QjFCLFFBQVFkLHVEQUFZQSxDQUFDOEMsU0FBUztnQkFDOUIxQixXQUFXdEIsbUVBQWVBO1lBQzVCO1lBRUEsTUFBTTRDLGFBQWEsTUFBTTdDLDBEQUFNQSxDQUFDMkM7WUFDaEMsSUFBSSxDQUFDRSxXQUFXZixNQUFNLElBQUk7Z0JBQ3hCLE1BQU0sSUFBSUMsTUFBTTtZQUNsQjtZQUVBLE9BQU8sTUFBTXZCLGlCQUFpQnFDO1FBQ2hDLEVBQUUsT0FBT0wsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsNEJBQTRCQTtZQUMxQyxNQUFNQTtRQUNSO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9maXJlYmFzZS1yYWZmbGUtd3JpdGUtc2VydmljZS50cz84NWMxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGNvbGxlY3Rpb24sXG4gIGFkZERvYyxcbiAgdXBkYXRlRG9jLFxuICBkb2MsXG4gIGdldERvYyxcbiAgc2VydmVyVGltZXN0YW1wLFxuICBRdWVyeURvY3VtZW50U25hcHNob3QsXG4gIERvY3VtZW50RGF0YSxcbn0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcbmltcG9ydCB7IGRiIH0gZnJvbSAnQC9saWIvZmlyZWJhc2UnO1xuaW1wb3J0IHsgUmFmZmxlLCBSYWZmbGVTdGF0dXMsIENyZWF0ZVJhZmZsZUR0bywgVXBkYXRlUmFmZmxlRHRvIH0gZnJvbSAnQC90eXBlcy9yYWZmbGUnO1xuaW1wb3J0IHsgUHJvZHVjdCB9IGZyb20gJ0AvdHlwZXMvcHJvZHVjdCc7XG5cbi8vIEhlbHBlciBwYXJhIGNvbnZlcnRpciBGaXJlc3RvcmUgdGltZXN0YW1wIGEgRGF0ZVxuY29uc3QgY29udmVydFRpbWVzdGFtcCA9ICh0aW1lc3RhbXA6IGFueSk6IERhdGUgPT4ge1xuICBpZiAodGltZXN0YW1wPy50b0RhdGUpIHtcbiAgICByZXR1cm4gdGltZXN0YW1wLnRvRGF0ZSgpO1xuICB9XG4gIGlmICh0aW1lc3RhbXAgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIHRpbWVzdGFtcDtcbiAgfVxuICBpZiAodHlwZW9mIHRpbWVzdGFtcCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wKTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoKTtcbn07XG5cbi8vIEhlbHBlciBwYXJhIGNvbnZlcnRpciBkb2N1bWVudG8gZGUgRmlyZXN0b3JlIGEgUmFmZmxlXG5jb25zdCBjb252ZXJ0UmFmZmxlRG9jID0gYXN5bmMgKGRvY1NuYXA6IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdDxEb2N1bWVudERhdGE+KTogUHJvbWlzZTxSYWZmbGU+ID0+IHtcbiAgY29uc3QgZGF0YSA9IGRvY1NuYXAuZGF0YSgpO1xuICByZXR1cm4ge1xuICAgIGlkOiBkb2NTbmFwLmlkLFxuICAgIHNob3BJZDogZGF0YS5zaG9wSWQgfHwgJycsXG4gICAgcHJvZHVjdElkOiBkYXRhLnByb2R1Y3RJZCB8fCAnJyxcbiAgICBwcm9kdWN0VmFsdWU6IGRhdGEucHJvZHVjdFZhbHVlIHx8IDAsXG4gICAgdG90YWxUaWNrZXRzOiBkYXRhLnRvdGFsVGlja2V0cyB8fCAwLFxuICAgIHNvbGRUaWNrZXRzOiBkYXRhLnNvbGRUaWNrZXRzIHx8IDAsXG4gICAgc3RhdHVzOiBkYXRhLnN0YXR1cyB8fCBSYWZmbGVTdGF0dXMuRFJBRlQsXG4gICAgcmVxdWlyZXNEZXBvc2l0OiBkYXRhLnJlcXVpcmVzRGVwb3NpdCB8fCBmYWxzZSxcbiAgICB3aW5uZXJUaWNrZXRJZDogZGF0YS53aW5uZXJUaWNrZXRJZCxcbiAgICBzcGVjaWFsQ29uZGl0aW9uczogZGF0YS5zcGVjaWFsQ29uZGl0aW9ucyxcbiAgICBjcmVhdGVkQXQ6IGNvbnZlcnRUaW1lc3RhbXAoZGF0YS5jcmVhdGVkQXQpLFxuICAgIHVwZGF0ZWRBdDogY29udmVydFRpbWVzdGFtcChkYXRhLnVwZGF0ZWRBdCksXG4gICAgYWN0aXZhdGVkQXQ6IGRhdGEuYWN0aXZhdGVkQXQgPyBjb252ZXJ0VGltZXN0YW1wKGRhdGEuYWN0aXZhdGVkQXQpIDogdW5kZWZpbmVkLFxuICAgIHJhZmZsZUV4ZWN1dGVkQXQ6IGRhdGEucmFmZmxlRXhlY3V0ZWRBdCA/IGNvbnZlcnRUaW1lc3RhbXAoZGF0YS5yYWZmbGVFeGVjdXRlZEF0KSA6IHVuZGVmaW5lZCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaXJlYmFzZVJhZmZsZVdyaXRlU2VydmljZSA9IHtcbiAgLyoqXG4gICAqIENyZWEgdW4gbnVldm8gc29ydGVvXG4gICAqIENhbGN1bGEgYXV0b23DoXRpY2FtZW50ZSBsb3MgdGlja2V0cyBjb21vIGVsIGRvYmxlIGRlbCB2YWxvciBkZWwgcHJvZHVjdG9cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVJhZmZsZShkYXRhOiBDcmVhdGVSYWZmbGVEdG8pOiBQcm9taXNlPFJhZmZsZT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBPYnRlbmVyIGVsIHByb2R1Y3RvIHBhcmEgY2FsY3VsYXIgbG9zIHRpY2tldHNcbiAgICAgIGNvbnN0IHByb2R1Y3REb2MgPSBhd2FpdCBnZXREb2MoZG9jKGRiLCAncHJvZHVjdHMnLCBkYXRhLnByb2R1Y3RJZCkpO1xuICAgICAgaWYgKCFwcm9kdWN0RG9jLmV4aXN0cygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZHVjdG8gbm8gZW5jb250cmFkbycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9kdWN0RGF0YSA9IHByb2R1Y3REb2MuZGF0YSgpIGFzIFByb2R1Y3Q7XG4gICAgICBjb25zdCBwcm9kdWN0VmFsdWUgPSBwcm9kdWN0RGF0YS52YWx1ZSB8fCAwO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhciB0aWNrZXRzOiBkb2JsZSBkZWwgdmFsb3IgZGVsIHByb2R1Y3RvXG4gICAgICBjb25zdCB0b3RhbFRpY2tldHMgPSBNYXRoLmZsb29yKHByb2R1Y3RWYWx1ZSAqIDIpO1xuXG4gICAgICBpZiAodG90YWxUaWNrZXRzIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbCB2YWxvciBkZWwgcHJvZHVjdG8gZGViZSBzZXIgbWF5b3IgYSAwJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJhZmZsZXNSZWYgPSBjb2xsZWN0aW9uKGRiLCAncmFmZmxlcycpO1xuICAgICAgY29uc3QgcmFmZmxlRGF0YSA9IHtcbiAgICAgICAgc2hvcElkOiBkYXRhLnNob3BJZCxcbiAgICAgICAgcHJvZHVjdElkOiBkYXRhLnByb2R1Y3RJZCxcbiAgICAgICAgcHJvZHVjdFZhbHVlOiBwcm9kdWN0VmFsdWUsXG4gICAgICAgIHRvdGFsVGlja2V0czogdG90YWxUaWNrZXRzLFxuICAgICAgICBzb2xkVGlja2V0czogMCxcbiAgICAgICAgc3RhdHVzOiBSYWZmbGVTdGF0dXMuRFJBRlQsXG4gICAgICAgIHJlcXVpcmVzRGVwb3NpdDogcHJvZHVjdERhdGEucmVxdWlyZXNEZXBvc2l0IHx8IGZhbHNlLFxuICAgICAgICBzcGVjaWFsQ29uZGl0aW9uczogZGF0YS5zcGVjaWFsQ29uZGl0aW9ucyB8fCBudWxsLFxuICAgICAgICB3aW5uZXJUaWNrZXRJZDogbnVsbCxcbiAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhyYWZmbGVzUmVmLCByYWZmbGVEYXRhKTtcbiAgICAgIGNvbnN0IHJhZmZsZURvYyA9IGF3YWl0IGdldERvYyhkb2NSZWYpO1xuICAgICAgXG4gICAgICBpZiAoIXJhZmZsZURvYy5leGlzdHMoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFsIGNyZWFyIGVsIHNvcnRlbycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgY29udmVydFJhZmZsZURvYyhyYWZmbGVEb2MgYXMgUXVlcnlEb2N1bWVudFNuYXBzaG90PERvY3VtZW50RGF0YT4pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyByYWZmbGU6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBY3R1YWxpemEgdW4gc29ydGVvIGV4aXN0ZW50ZVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlUmFmZmxlKGlkOiBzdHJpbmcsIGRhdGE6IFVwZGF0ZVJhZmZsZUR0byk6IFByb21pc2U8UmFmZmxlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhZmZsZVJlZiA9IGRvYyhkYiwgJ3JhZmZsZXMnLCBpZCk7XG4gICAgICBjb25zdCB1cGRhdGVEYXRhOiBhbnkgPSB7XG4gICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICB9O1xuXG4gICAgICBpZiAoZGF0YS5zcGVjaWFsQ29uZGl0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwZGF0ZURhdGEuc3BlY2lhbENvbmRpdGlvbnMgPSBkYXRhLnNwZWNpYWxDb25kaXRpb25zO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB1cGRhdGVEb2MocmFmZmxlUmVmLCB1cGRhdGVEYXRhKTtcbiAgICAgIFxuICAgICAgY29uc3QgdXBkYXRlZERvYyA9IGF3YWl0IGdldERvYyhyYWZmbGVSZWYpO1xuICAgICAgaWYgKCF1cGRhdGVkRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU29ydGVvIG5vIGVuY29udHJhZG8nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IGNvbnZlcnRSYWZmbGVEb2ModXBkYXRlZERvYyBhcyBRdWVyeURvY3VtZW50U25hcHNob3Q8RG9jdW1lbnREYXRhPik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHJhZmZsZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVudsOtYSB1biBzb3J0ZW8gcGFyYSBhcHJvYmFjacOzblxuICAgKi9cbiAgYXN5bmMgc3VibWl0Rm9yQXBwcm92YWwoaWQ6IHN0cmluZyk6IFByb21pc2U8UmFmZmxlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhZmZsZVJlZiA9IGRvYyhkYiwgJ3JhZmZsZXMnLCBpZCk7XG4gICAgICBhd2FpdCB1cGRhdGVEb2MocmFmZmxlUmVmLCB7XG4gICAgICAgIHN0YXR1czogUmFmZmxlU3RhdHVzLlBFTkRJTkdfQVBQUk9WQUwsXG4gICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdXBkYXRlZERvYyA9IGF3YWl0IGdldERvYyhyYWZmbGVSZWYpO1xuICAgICAgaWYgKCF1cGRhdGVkRG9jLmV4aXN0cygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU29ydGVvIG5vIGVuY29udHJhZG8nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IGNvbnZlcnRSYWZmbGVEb2ModXBkYXRlZERvYyBhcyBRdWVyeURvY3VtZW50U25hcHNob3Q8RG9jdW1lbnREYXRhPik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN1Ym1pdHRpbmcgcmFmZmxlIGZvciBhcHByb3ZhbDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbmNlbGEgdW4gc29ydGVvXG4gICAqL1xuICBhc3luYyBjYW5jZWxSYWZmbGUoaWQ6IHN0cmluZyk6IFByb21pc2U8UmFmZmxlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhZmZsZVJlZiA9IGRvYyhkYiwgJ3JhZmZsZXMnLCBpZCk7XG4gICAgICBhd2FpdCB1cGRhdGVEb2MocmFmZmxlUmVmLCB7XG4gICAgICAgIHN0YXR1czogUmFmZmxlU3RhdHVzLkNBTkNFTExFRCxcbiAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1cGRhdGVkRG9jID0gYXdhaXQgZ2V0RG9jKHJhZmZsZVJlZik7XG4gICAgICBpZiAoIXVwZGF0ZWREb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3J0ZW8gbm8gZW5jb250cmFkbycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgY29udmVydFJhZmZsZURvYyh1cGRhdGVkRG9jIGFzIFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdDxEb2N1bWVudERhdGE+KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FuY2VsbGluZyByYWZmbGU6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxufTtcblxuIl0sIm5hbWVzIjpbImNvbGxlY3Rpb24iLCJhZGREb2MiLCJ1cGRhdGVEb2MiLCJkb2MiLCJnZXREb2MiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJkYiIsIlJhZmZsZVN0YXR1cyIsImNvbnZlcnRUaW1lc3RhbXAiLCJ0aW1lc3RhbXAiLCJ0b0RhdGUiLCJEYXRlIiwiY29udmVydFJhZmZsZURvYyIsImRvY1NuYXAiLCJkYXRhIiwiaWQiLCJzaG9wSWQiLCJwcm9kdWN0SWQiLCJwcm9kdWN0VmFsdWUiLCJ0b3RhbFRpY2tldHMiLCJzb2xkVGlja2V0cyIsInN0YXR1cyIsIkRSQUZUIiwicmVxdWlyZXNEZXBvc2l0Iiwid2lubmVyVGlja2V0SWQiLCJzcGVjaWFsQ29uZGl0aW9ucyIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsImFjdGl2YXRlZEF0IiwidW5kZWZpbmVkIiwicmFmZmxlRXhlY3V0ZWRBdCIsImZpcmViYXNlUmFmZmxlV3JpdGVTZXJ2aWNlIiwiY3JlYXRlUmFmZmxlIiwicHJvZHVjdERvYyIsImV4aXN0cyIsIkVycm9yIiwicHJvZHVjdERhdGEiLCJ2YWx1ZSIsIk1hdGgiLCJmbG9vciIsInJhZmZsZXNSZWYiLCJyYWZmbGVEYXRhIiwiZG9jUmVmIiwicmFmZmxlRG9jIiwiZXJyb3IiLCJjb25zb2xlIiwidXBkYXRlUmFmZmxlIiwicmFmZmxlUmVmIiwidXBkYXRlRGF0YSIsInVwZGF0ZWREb2MiLCJzdWJtaXRGb3JBcHByb3ZhbCIsIlBFTkRJTkdfQVBQUk9WQUwiLCJjYW5jZWxSYWZmbGUiLCJDQU5DRUxMRUQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/firebase-raffle-write-service.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/raffle-service.ts":
/*!****************************************!*\
  !*** ./src/services/raffle-service.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raffleService: function() { return /* binding */ raffleService; }\n/* harmony export */ });\n/* harmony import */ var _firebase_raffle_write_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebase-raffle-write-service */ \"(app-pages-browser)/./src/services/firebase-raffle-write-service.ts\");\n/* harmony import */ var _firebase_raffle_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase-raffle-service */ \"(app-pages-browser)/./src/services/firebase-raffle-service.ts\");\n\n\nconst raffleService = {\n    // Operaciones de lectura usan firebase-raffle-service\n    async getRafflesByShop (shopId) {\n        const result = await _firebase_raffle_service__WEBPACK_IMPORTED_MODULE_1__.firebaseRaffleService.getRafflesByShop(shopId, {\n            limit: 100\n        });\n        return result.data;\n    },\n    async getRaffleById (id) {\n        return _firebase_raffle_service__WEBPACK_IMPORTED_MODULE_1__.firebaseRaffleService.getRaffleById(id);\n    },\n    async getActiveRaffles () {\n        const result = await _firebase_raffle_service__WEBPACK_IMPORTED_MODULE_1__.firebaseRaffleService.getActiveRaffles({\n            limit: 100\n        });\n        return result.data;\n    },\n    async getAllRaffles () {\n        // Obtener todos los sorteos (sin filtro de status)\n        const { collection, getDocs } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! firebase/firestore */ \"(app-pages-browser)/../node_modules/firebase/firestore/dist/esm/index.esm.js\"));\n        const { db } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\"));\n        const rafflesRef = collection(db, \"raffles\");\n        const snapshot = await getDocs(rafflesRef);\n        const raffles = [];\n        for (const docSnap of snapshot.docs){\n            var _data_createdAt, _data_updatedAt, _data_activatedAt, _data_raffleExecutedAt;\n            const data = docSnap.data();\n            raffles.push({\n                id: docSnap.id,\n                shopId: data.shopId || \"\",\n                productId: data.productId || \"\",\n                productValue: data.productValue || 0,\n                totalTickets: data.totalTickets || 0,\n                soldTickets: data.soldTickets || 0,\n                status: data.status || \"draft\",\n                requiresDeposit: data.requiresDeposit || false,\n                winnerTicketId: data.winnerTicketId,\n                specialConditions: data.specialConditions,\n                createdAt: ((_data_createdAt = data.createdAt) === null || _data_createdAt === void 0 ? void 0 : _data_createdAt.toDate()) || new Date(),\n                updatedAt: ((_data_updatedAt = data.updatedAt) === null || _data_updatedAt === void 0 ? void 0 : _data_updatedAt.toDate()) || new Date(),\n                activatedAt: (_data_activatedAt = data.activatedAt) === null || _data_activatedAt === void 0 ? void 0 : _data_activatedAt.toDate(),\n                raffleExecutedAt: (_data_raffleExecutedAt = data.raffleExecutedAt) === null || _data_raffleExecutedAt === void 0 ? void 0 : _data_raffleExecutedAt.toDate()\n            });\n        }\n        return raffles;\n    },\n    // Operaciones de escritura usan firebase-raffle-write-service\n    async createRaffle (data) {\n        return _firebase_raffle_write_service__WEBPACK_IMPORTED_MODULE_0__.firebaseRaffleWriteService.createRaffle(data);\n    },\n    async updateRaffle (id, data) {\n        return _firebase_raffle_write_service__WEBPACK_IMPORTED_MODULE_0__.firebaseRaffleWriteService.updateRaffle(id, data);\n    },\n    async submitForApproval (id) {\n        return _firebase_raffle_write_service__WEBPACK_IMPORTED_MODULE_0__.firebaseRaffleWriteService.submitForApproval(id);\n    },\n    async cancelRaffle (id) {\n        return _firebase_raffle_write_service__WEBPACK_IMPORTED_MODULE_0__.firebaseRaffleWriteService.cancelRaffle(id);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9yYWZmbGUtc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkU7QUFDWDtBQUczRCxNQUFNRSxnQkFBZ0I7SUFDM0Isc0RBQXNEO0lBQ3RELE1BQU1DLGtCQUFpQkMsTUFBYztRQUNuQyxNQUFNQyxTQUFTLE1BQU1KLDJFQUFxQkEsQ0FBQ0UsZ0JBQWdCLENBQUNDLFFBQVE7WUFBRUUsT0FBTztRQUFJO1FBQ2pGLE9BQU9ELE9BQU9FLElBQUk7SUFDcEI7SUFFQSxNQUFNQyxlQUFjQyxFQUFVO1FBQzVCLE9BQU9SLDJFQUFxQkEsQ0FBQ08sYUFBYSxDQUFDQztJQUM3QztJQUVBLE1BQU1DO1FBQ0osTUFBTUwsU0FBUyxNQUFNSiwyRUFBcUJBLENBQUNTLGdCQUFnQixDQUFDO1lBQUVKLE9BQU87UUFBSTtRQUN6RSxPQUFPRCxPQUFPRSxJQUFJO0lBQ3BCO0lBRUEsTUFBTUk7UUFDSixtREFBbUQ7UUFDbkQsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRSxHQUFHLE1BQU0sOExBQU87UUFDN0MsTUFBTSxFQUFFQyxFQUFFLEVBQUUsR0FBRyxNQUFNLHVKQUFPO1FBQzVCLE1BQU1DLGFBQWFILFdBQVdFLElBQUk7UUFDbEMsTUFBTUUsV0FBVyxNQUFNSCxRQUFRRTtRQUMvQixNQUFNRSxVQUFvQixFQUFFO1FBRTVCLEtBQUssTUFBTUMsV0FBV0YsU0FBU0csSUFBSSxDQUFFO2dCQWF0QlosaUJBQ0FBLGlCQUNFQSxtQkFDS0E7WUFmcEIsTUFBTUEsT0FBT1csUUFBUVgsSUFBSTtZQUN6QlUsUUFBUUcsSUFBSSxDQUFDO2dCQUNYWCxJQUFJUyxRQUFRVCxFQUFFO2dCQUNkTCxRQUFRRyxLQUFLSCxNQUFNLElBQUk7Z0JBQ3ZCaUIsV0FBV2QsS0FBS2MsU0FBUyxJQUFJO2dCQUM3QkMsY0FBY2YsS0FBS2UsWUFBWSxJQUFJO2dCQUNuQ0MsY0FBY2hCLEtBQUtnQixZQUFZLElBQUk7Z0JBQ25DQyxhQUFhakIsS0FBS2lCLFdBQVcsSUFBSTtnQkFDakNDLFFBQVFsQixLQUFLa0IsTUFBTSxJQUFJO2dCQUN2QkMsaUJBQWlCbkIsS0FBS21CLGVBQWUsSUFBSTtnQkFDekNDLGdCQUFnQnBCLEtBQUtvQixjQUFjO2dCQUNuQ0MsbUJBQW1CckIsS0FBS3FCLGlCQUFpQjtnQkFDekNDLFdBQVd0QixFQUFBQSxrQkFBQUEsS0FBS3NCLFNBQVMsY0FBZHRCLHNDQUFBQSxnQkFBZ0J1QixNQUFNLE9BQU0sSUFBSUM7Z0JBQzNDQyxXQUFXekIsRUFBQUEsa0JBQUFBLEtBQUt5QixTQUFTLGNBQWR6QixzQ0FBQUEsZ0JBQWdCdUIsTUFBTSxPQUFNLElBQUlDO2dCQUMzQ0UsV0FBVyxHQUFFMUIsb0JBQUFBLEtBQUswQixXQUFXLGNBQWhCMUIsd0NBQUFBLGtCQUFrQnVCLE1BQU07Z0JBQ3JDSSxnQkFBZ0IsR0FBRTNCLHlCQUFBQSxLQUFLMkIsZ0JBQWdCLGNBQXJCM0IsNkNBQUFBLHVCQUF1QnVCLE1BQU07WUFDakQ7UUFDRjtRQUVBLE9BQU9iO0lBQ1Q7SUFFQSw4REFBOEQ7SUFDOUQsTUFBTWtCLGNBQWE1QixJQUFxQjtRQUN0QyxPQUFPUCxzRkFBMEJBLENBQUNtQyxZQUFZLENBQUM1QjtJQUNqRDtJQUVBLE1BQU02QixjQUFhM0IsRUFBVSxFQUFFRixJQUFxQjtRQUNsRCxPQUFPUCxzRkFBMEJBLENBQUNvQyxZQUFZLENBQUMzQixJQUFJRjtJQUNyRDtJQUVBLE1BQU04QixtQkFBa0I1QixFQUFVO1FBQ2hDLE9BQU9ULHNGQUEwQkEsQ0FBQ3FDLGlCQUFpQixDQUFDNUI7SUFDdEQ7SUFFQSxNQUFNNkIsY0FBYTdCLEVBQVU7UUFDM0IsT0FBT1Qsc0ZBQTBCQSxDQUFDc0MsWUFBWSxDQUFDN0I7SUFDakQ7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9yYWZmbGUtc2VydmljZS50cz82MTRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZpcmViYXNlUmFmZmxlV3JpdGVTZXJ2aWNlIH0gZnJvbSAnLi9maXJlYmFzZS1yYWZmbGUtd3JpdGUtc2VydmljZSc7XG5pbXBvcnQgeyBmaXJlYmFzZVJhZmZsZVNlcnZpY2UgfSBmcm9tICcuL2ZpcmViYXNlLXJhZmZsZS1zZXJ2aWNlJztcbmltcG9ydCB7IFJhZmZsZSwgQ3JlYXRlUmFmZmxlRHRvLCBVcGRhdGVSYWZmbGVEdG8gfSBmcm9tICdAL3R5cGVzL3JhZmZsZSc7XG5cbmV4cG9ydCBjb25zdCByYWZmbGVTZXJ2aWNlID0ge1xuICAvLyBPcGVyYWNpb25lcyBkZSBsZWN0dXJhIHVzYW4gZmlyZWJhc2UtcmFmZmxlLXNlcnZpY2VcbiAgYXN5bmMgZ2V0UmFmZmxlc0J5U2hvcChzaG9wSWQ6IHN0cmluZyk6IFByb21pc2U8UmFmZmxlW10+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaXJlYmFzZVJhZmZsZVNlcnZpY2UuZ2V0UmFmZmxlc0J5U2hvcChzaG9wSWQsIHsgbGltaXQ6IDEwMCB9KTtcbiAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gIH0sXG5cbiAgYXN5bmMgZ2V0UmFmZmxlQnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxSYWZmbGU+IHtcbiAgICByZXR1cm4gZmlyZWJhc2VSYWZmbGVTZXJ2aWNlLmdldFJhZmZsZUJ5SWQoaWQpO1xuICB9LFxuXG4gIGFzeW5jIGdldEFjdGl2ZVJhZmZsZXMoKTogUHJvbWlzZTxSYWZmbGVbXT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpcmViYXNlUmFmZmxlU2VydmljZS5nZXRBY3RpdmVSYWZmbGVzKHsgbGltaXQ6IDEwMCB9KTtcbiAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gIH0sXG5cbiAgYXN5bmMgZ2V0QWxsUmFmZmxlcygpOiBQcm9taXNlPFJhZmZsZVtdPiB7XG4gICAgLy8gT2J0ZW5lciB0b2RvcyBsb3Mgc29ydGVvcyAoc2luIGZpbHRybyBkZSBzdGF0dXMpXG4gICAgY29uc3QgeyBjb2xsZWN0aW9uLCBnZXREb2NzIH0gPSBhd2FpdCBpbXBvcnQoJ2ZpcmViYXNlL2ZpcmVzdG9yZScpO1xuICAgIGNvbnN0IHsgZGIgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvZmlyZWJhc2UnKTtcbiAgICBjb25zdCByYWZmbGVzUmVmID0gY29sbGVjdGlvbihkYiwgJ3JhZmZsZXMnKTtcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocmFmZmxlc1JlZik7XG4gICAgY29uc3QgcmFmZmxlczogUmFmZmxlW10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGRvY1NuYXAgb2Ygc25hcHNob3QuZG9jcykge1xuICAgICAgY29uc3QgZGF0YSA9IGRvY1NuYXAuZGF0YSgpO1xuICAgICAgcmFmZmxlcy5wdXNoKHtcbiAgICAgICAgaWQ6IGRvY1NuYXAuaWQsXG4gICAgICAgIHNob3BJZDogZGF0YS5zaG9wSWQgfHwgJycsXG4gICAgICAgIHByb2R1Y3RJZDogZGF0YS5wcm9kdWN0SWQgfHwgJycsXG4gICAgICAgIHByb2R1Y3RWYWx1ZTogZGF0YS5wcm9kdWN0VmFsdWUgfHwgMCxcbiAgICAgICAgdG90YWxUaWNrZXRzOiBkYXRhLnRvdGFsVGlja2V0cyB8fCAwLFxuICAgICAgICBzb2xkVGlja2V0czogZGF0YS5zb2xkVGlja2V0cyB8fCAwLFxuICAgICAgICBzdGF0dXM6IGRhdGEuc3RhdHVzIHx8ICdkcmFmdCcsXG4gICAgICAgIHJlcXVpcmVzRGVwb3NpdDogZGF0YS5yZXF1aXJlc0RlcG9zaXQgfHwgZmFsc2UsXG4gICAgICAgIHdpbm5lclRpY2tldElkOiBkYXRhLndpbm5lclRpY2tldElkLFxuICAgICAgICBzcGVjaWFsQ29uZGl0aW9uczogZGF0YS5zcGVjaWFsQ29uZGl0aW9ucyxcbiAgICAgICAgY3JlYXRlZEF0OiBkYXRhLmNyZWF0ZWRBdD8udG9EYXRlKCkgfHwgbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBkYXRhLnVwZGF0ZWRBdD8udG9EYXRlKCkgfHwgbmV3IERhdGUoKSxcbiAgICAgICAgYWN0aXZhdGVkQXQ6IGRhdGEuYWN0aXZhdGVkQXQ/LnRvRGF0ZSgpLFxuICAgICAgICByYWZmbGVFeGVjdXRlZEF0OiBkYXRhLnJhZmZsZUV4ZWN1dGVkQXQ/LnRvRGF0ZSgpLFxuICAgICAgfSBhcyBSYWZmbGUpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmFmZmxlcztcbiAgfSxcblxuICAvLyBPcGVyYWNpb25lcyBkZSBlc2NyaXR1cmEgdXNhbiBmaXJlYmFzZS1yYWZmbGUtd3JpdGUtc2VydmljZVxuICBhc3luYyBjcmVhdGVSYWZmbGUoZGF0YTogQ3JlYXRlUmFmZmxlRHRvKTogUHJvbWlzZTxSYWZmbGU+IHtcbiAgICByZXR1cm4gZmlyZWJhc2VSYWZmbGVXcml0ZVNlcnZpY2UuY3JlYXRlUmFmZmxlKGRhdGEpO1xuICB9LFxuXG4gIGFzeW5jIHVwZGF0ZVJhZmZsZShpZDogc3RyaW5nLCBkYXRhOiBVcGRhdGVSYWZmbGVEdG8pOiBQcm9taXNlPFJhZmZsZT4ge1xuICAgIHJldHVybiBmaXJlYmFzZVJhZmZsZVdyaXRlU2VydmljZS51cGRhdGVSYWZmbGUoaWQsIGRhdGEpO1xuICB9LFxuXG4gIGFzeW5jIHN1Ym1pdEZvckFwcHJvdmFsKGlkOiBzdHJpbmcpOiBQcm9taXNlPFJhZmZsZT4ge1xuICAgIHJldHVybiBmaXJlYmFzZVJhZmZsZVdyaXRlU2VydmljZS5zdWJtaXRGb3JBcHByb3ZhbChpZCk7XG4gIH0sXG5cbiAgYXN5bmMgY2FuY2VsUmFmZmxlKGlkOiBzdHJpbmcpOiBQcm9taXNlPFJhZmZsZT4ge1xuICAgIHJldHVybiBmaXJlYmFzZVJhZmZsZVdyaXRlU2VydmljZS5jYW5jZWxSYWZmbGUoaWQpO1xuICB9LFxufTsiXSwibmFtZXMiOlsiZmlyZWJhc2VSYWZmbGVXcml0ZVNlcnZpY2UiLCJmaXJlYmFzZVJhZmZsZVNlcnZpY2UiLCJyYWZmbGVTZXJ2aWNlIiwiZ2V0UmFmZmxlc0J5U2hvcCIsInNob3BJZCIsInJlc3VsdCIsImxpbWl0IiwiZGF0YSIsImdldFJhZmZsZUJ5SWQiLCJpZCIsImdldEFjdGl2ZVJhZmZsZXMiLCJnZXRBbGxSYWZmbGVzIiwiY29sbGVjdGlvbiIsImdldERvY3MiLCJkYiIsInJhZmZsZXNSZWYiLCJzbmFwc2hvdCIsInJhZmZsZXMiLCJkb2NTbmFwIiwiZG9jcyIsInB1c2giLCJwcm9kdWN0SWQiLCJwcm9kdWN0VmFsdWUiLCJ0b3RhbFRpY2tldHMiLCJzb2xkVGlja2V0cyIsInN0YXR1cyIsInJlcXVpcmVzRGVwb3NpdCIsIndpbm5lclRpY2tldElkIiwic3BlY2lhbENvbmRpdGlvbnMiLCJjcmVhdGVkQXQiLCJ0b0RhdGUiLCJEYXRlIiwidXBkYXRlZEF0IiwiYWN0aXZhdGVkQXQiLCJyYWZmbGVFeGVjdXRlZEF0IiwiY3JlYXRlUmFmZmxlIiwidXBkYXRlUmFmZmxlIiwic3VibWl0Rm9yQXBwcm92YWwiLCJjYW5jZWxSYWZmbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/raffle-service.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/types/raffle.ts":
/*!*****************************!*\
  !*** ./src/types/raffle.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RaffleStatus: function() { return /* binding */ RaffleStatus; }\n/* harmony export */ });\nvar RaffleStatus;\n(function(RaffleStatus) {\n    RaffleStatus[\"DRAFT\"] = \"draft\";\n    RaffleStatus[\"PENDING_APPROVAL\"] = \"pending_approval\";\n    RaffleStatus[\"ACTIVE\"] = \"active\";\n    RaffleStatus[\"PAUSED\"] = \"paused\";\n    RaffleStatus[\"SOLD_OUT\"] = \"sold_out\";\n    RaffleStatus[\"FINISHED\"] = \"finished\";\n    RaffleStatus[\"CANCELLED\"] = \"cancelled\";\n    RaffleStatus[\"REJECTED\"] = \"rejected\";\n})(RaffleStatus || (RaffleStatus = {}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy90eXBlcy9yYWZmbGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7VUFHWUE7Ozs7Ozs7OztHQUFBQSxpQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3R5cGVzL3JhZmZsZS50cz9kYzUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByb2R1Y3QgfSBmcm9tICcuL3Byb2R1Y3QnO1xuaW1wb3J0IHsgU2hvcCB9IGZyb20gJy4vc2hvcCc7XG5cbmV4cG9ydCBlbnVtIFJhZmZsZVN0YXR1cyB7XG4gIERSQUZUID0gJ2RyYWZ0JyxcbiAgUEVORElOR19BUFBST1ZBTCA9ICdwZW5kaW5nX2FwcHJvdmFsJyxcbiAgQUNUSVZFID0gJ2FjdGl2ZScsXG4gIFBBVVNFRCA9ICdwYXVzZWQnLFxuICBTT0xEX09VVCA9ICdzb2xkX291dCcsXG4gIEZJTklTSEVEID0gJ2ZpbmlzaGVkJyxcbiAgQ0FOQ0VMTEVEID0gJ2NhbmNlbGxlZCcsXG4gIFJFSkVDVEVEID0gJ3JlamVjdGVkJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSYWZmbGUge1xuICBpZDogc3RyaW5nO1xuICBzaG9wSWQ6IHN0cmluZztcbiAgcHJvZHVjdElkOiBzdHJpbmc7XG4gIHByb2R1Y3RWYWx1ZTogbnVtYmVyO1xuICB0b3RhbFRpY2tldHM6IG51bWJlcjtcbiAgc29sZFRpY2tldHM6IG51bWJlcjtcbiAgc3RhdHVzOiBSYWZmbGVTdGF0dXM7XG4gIHJlcXVpcmVzRGVwb3NpdDogYm9vbGVhbjtcbiAgd2lubmVyVGlja2V0SWQ/OiBzdHJpbmc7XG4gIHNwZWNpYWxDb25kaXRpb25zPzogc3RyaW5nO1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIHVwZGF0ZWRBdDogRGF0ZTtcbiAgYWN0aXZhdGVkQXQ/OiBEYXRlO1xuICByYWZmbGVFeGVjdXRlZEF0PzogRGF0ZTtcbiAgc2hvcD86IFNob3A7XG4gIHByb2R1Y3Q/OiBQcm9kdWN0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZVJhZmZsZUR0byB7XG4gIHNob3BJZDogc3RyaW5nO1xuICBwcm9kdWN0SWQ6IHN0cmluZztcbiAgc3BlY2lhbENvbmRpdGlvbnM/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlUmFmZmxlRHRvIHtcbiAgc3BlY2lhbENvbmRpdGlvbnM/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmFmZmxlV2l0aFJlbGF0aW9ucyBleHRlbmRzIFJhZmZsZSB7XG4gIHNob3A6IFNob3A7XG4gIHByb2R1Y3Q6IFByb2R1Y3Q7XG59Il0sIm5hbWVzIjpbIlJhZmZsZVN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/types/raffle.ts\n"));

/***/ })

}]);